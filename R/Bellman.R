  #' Compute Bellman values at step i from step i+1, used in \code{Grid_Matrix}
  #'
  #' @param Data_week A "data.table" generated in Grid_Matrix code
  #' that contains:
  #'  * states Numeric. All the water values that can be set, listed in
  #'   decreasing order.
  #'  * value_inflow Numeric. Inflow values for each Monte-Carlo year.
  #'  * Rewards for each simulation value and each Monte-Carlo year.
  #'  * level_high Numeric. Highest possible reservoir value.
  #'  * level_low Numeric. Lowest possible reservoir value.
  #'  * states_next List of vectors enumerating all reachable states
  #' @param reward Data.frame reward generated by \code{get_Reward()}
  #' @param next_week_values_l Numeric. Bellman values at step i+1.
  #' @param E_max Numeric of length 1. Maximum energy that can be generated by
  #'   hydro storage over one step of time.
  #' @param P_max Numeric of length 1. Maximum energy that can be pumped to
  #' reservoir over one step of time.
  #' @param cvar_value numeric in [0,1]. the probability used in cvar algorithm.
  #' @param mcyears Vector. Monte Carlo years
  #' @param niveau_max Level max of the reservoir
  #' @param penalty_level_low Penalty for violating the bottom rule curve, comparable to the unsupplied energy
  #' @param penalty_level_high Penalty for violating the top rule curve, comparable to the spilled energy
  #' @param lvl_high Double. Upper rule curve for the considered week.
  #' @param lvl_low Double. Bottom rule curve for the considered week.
  #' @param overflow_cost Cost for overflow (equal to spillage cost of the area)
  #'
  #' @return a \code{data.table} like Data_week with the Bellman values
  #' @keywords internal
  Bellman <- function(Data_week,next_week_values_l,reward,E_max,P_max=0,
                      mcyears,cvar_value=1,niveau_max,
                      penalty_level_low,penalty_level_high,
                      lvl_high,lvl_low,overflow_cost){

    # Getting all possible transitions between a state for the current week and a state for the next week
    decision_space <- dplyr::select(reward,-c("timeId","reward"))

    #Get interpolation function of next Bellman values
    f_next_value <- get_bellman_values_interpolation(Data_week,next_week_values_l,mcyears)

    # Build a data.table from Data_week that list for each state and each MC year, the possible transitions
    df_SDP <- build_all_possible_decisions(Data_week,decision_space,f_next_value,
                                           mcyears,lvl_high,lvl_low,E_max,P_max,
                                           next_week_values_l,niveau_max,overflow_cost)

    # Reward interpolation
    setDT(df_SDP)
    setDT(reward)
    interp_reward <- reward[
      , .(interp_fun = list({
        ctrl <- sort(unique(control))
        rew  <- reward[order(control)][match(ctrl, sort(control))]
        approxfun(ctrl, rew)
      })),
      by = mcYear
    ]
    df_SDP <- interp_reward[df_SDP, on = .(mcYear = years)][, reward := interp_fun[[1]](control), by = mcYear][, interp_fun := NULL]

    # For each transition (control), find the associated reward and for each next state,
    # calculate penalties for violating rule curves. Then, find for each MC year and each state,
    # the maximum sum of reward, next bellman value and penalties
    df_SDP <- df_SDP %>%
      dplyr::mutate(penalty_low = dplyr::if_else(.data$next_state<=lvl_low,penalty_level_low*(.data$next_state-lvl_low),0),
             penalty_high = dplyr::if_else(.data$next_state>=lvl_high,penalty_level_high*(lvl_high-.data$next_state),0),
             sum=.data$reward+.data$next_value+.data$penalty_low+.data$penalty_high) %>%
      dplyr::group_by(.data$mcYear,.data$states) %>%
      dplyr::filter(.data$sum==max(.data$sum)) %>%
      dplyr::slice_max(.data$next_state, with_ties = F) %>%
      dplyr::select(-c("value_node","transition","transition_reward",
                "next_bellman_value")) %>%
      dplyr::rename("value_node"="sum","transition"="control","transition_reward"="reward",
             "next_bellman_value"="next_value","years"="mcYear")

    assertthat::assert_that(nrow(df_SDP)==nrow(Data_week),msg=paste0("Problem with Bellman"))

    # reorder df_SDP as Data_week and then replacing values for the week
    Data_week <- dplyr::left_join(Data_week[,-c("value_node","transition","transition_reward",
                                         "next_bellman_value")],df_SDP[,c("years","states","value_node","transition",
                                                                          "transition_reward","next_bellman_value")],
                           by=c("years","states"))

    if(cvar_value==1){
      # mean all values
      Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid, FUN=mean)

      return(Data_week)
    } else {
      Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid,
                                         FUN=function(x) mean(x[x<=stats::quantile(x,cvar_value)]))
      return(Data_week)
    }

    return(Data_week)

}


#' Create approximation of reward function for each scenario, used in \code{Bellman}
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' reward database for each scenario (we suppose there is only one week at a time)
#'
#' @return List of \code{stats::approxfun} for each scenario
get_reward_interpolation <- function(Data_week){

  reward <- dplyr::distinct(Data_week[,c('years','reward_db')])

  f_reward_year <- sapply(reward$reward_db,FUN = function(df) stats::approxfun(df$control,df$reward))

  return(f_reward_year)
}

#' Create approximation of Bellman function for next week for each scenario, used in \code{Bellman} and
#' in \code{getOptimalTrend}
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' list of states and years evaluated (we suppose there is only one week at a time)
#' @param next_week_values Vector of Bellman values to interpolate
#' @param mcyears Vector of monte carlo years to take into account
#'
#' @return List of \code{stats::approxfun} for each scenario
get_bellman_values_interpolation <- function(Data_week,next_week_values,mcyears){

  df_next_week <- data.frame(years = Data_week$years,
                             next_state = Data_week$states,
                             next_value = next_week_values)

  f_next_value <- c()
  for (year in mcyears){
    df <- dplyr::filter(df_next_week, .data$years==year)
    f <- stats::approxfun(df$next_state, df$next_value)#,yleft = 0, yright=0)
    f_next_value <- c(f_next_value,f)
  }

  return(f_next_value)
}

#' Create a data frame with all possible transition and associated next state for
#' each scenario and each state for one particular week, used in \code{Bellman}.
#' For each next state, Bellman value is calculated.
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' list of states and years evaluated (we suppose there is only one week at a time)
#' as weel as inflows
#' @param decision_space Simulation constraints values for the week
#'  generated by \code{get_Reward} or \code{runWaterValuesSimulation}
#' @param f_next_value List of approximated Bellman functions for the next week,
#' generated by \code{get_bellman_values_interpolation}
#' @param mcyears Vector of monte carlo years to take into account
#' @param lvl_high Double, top rule curve for the end of the week in MWh
#' @param lvl_low Double, bottom rule curve for the end of the week in MWh
#' @param E_max Double, weekly maximum turbining power for the week
#' @param P_max Double, weekly maximum pumping power for the week
#' @param next_week_values Vector of Bellman values for the next week
#' @param niveau_max Reservoir capacity in MWh
#' @param overflow_cost Cost for overflow (equal to spillage cost of the area)
#' @param next_states possible states for next week
#'
#' @return Data frame with same format as Data week with 3 more columns :
#' next_state, control (transition to next state) and
#' next value (Bellman value of next state)
build_all_possible_decisions <- function(Data_week,decision_space,f_next_value,
                                         mcyears,lvl_high,lvl_low,E_max,P_max,
                                         next_week_values,niveau_max,overflow_cost,
                                         next_states = NULL){

  if (is.null(next_states)){
    next_states = Data_week$states
  }

  df_next_week <- data.frame(years = Data_week$years,
                             next_state = next_states,
                             next_value = next_week_values)

  future_states <- Data_week %>%
    dplyr::inner_join(df_next_week,by="years", relationship="many-to-many") %>%
    dplyr::mutate(control = -.data$next_state+.data$states+.data$hydroStorage)

  control_possible <- Data_week  %>%
    dplyr::right_join(decision_space,by=c("years"="mcYear")) %>%
    dplyr::rename("control"="u") %>%
    dplyr::mutate(next_state=dplyr::if_else(.data$states+.data$hydroStorage-.data$control>niveau_max,niveau_max,
                                            .data$states+.data$hydroStorage-.data$control)) %>%
    dplyr::mutate(overflow=dplyr::if_else(.data$states+.data$hydroStorage-.data$control>niveau_max,
                                          .data$states+.data$hydroStorage-.data$control-niveau_max,0)) %>%
    dplyr::mutate(next_value=mapply(function(y,x)f_next_value[[which(y==mcyears)]](x), .data$years, .data$next_state)+
                    .data$overflow*overflow_cost) %>%
    dplyr::select(-c("overflow"))

  control_min <- Data_week %>%
    dplyr::mutate(next_state=lvl_high) %>%
    dplyr::mutate(control = -.data$next_state+.data$states+.data$hydroStorage) %>%
    dplyr::mutate(next_value=mapply(function(y,x)f_next_value[[which(y==mcyears)]](x), .data$years, .data$next_state))

  control_max <- Data_week %>%
    dplyr::mutate(next_state=lvl_low) %>%
    dplyr::mutate(control = -.data$next_state+.data$states+.data$hydroStorage) %>%
    dplyr::mutate(next_value=mapply(function(y,x)f_next_value[[which(y==mcyears)]](x), .data$years, .data$next_state))

  df_SDP <- dplyr::bind_rows(future_states, control_possible, control_min, control_max) %>%
    dplyr::filter((-P_max<=.data$control)&(.data$control<=E_max)&(.data$next_state>=0))

  return(df_SDP)
}

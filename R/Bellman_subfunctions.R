
#' Create approximation of reward function for each scenario, used in \code{Bellman}
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' reward database for each scenario (we suppose there is only one week at a time)
#'
#' @return List of \code{stats::approxfun} for each scenario
get_reward_interpolation <- function(Data_week){

  reward <- dplyr::distinct(Data_week[,c('years','reward_db')])

  f_reward_year <- sapply(reward$reward_db,FUN = function(df) stats::approxfun(df$control,df$reward))

  return(f_reward_year)
}

#' Create approximation of Bellman function for each scenario, used in \code{Bellman} and
#' in \code{getOptimalTrend}
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' list of states and years evaluated (we suppose there is only one week at a time)
#' @param next_week_values Vector of Bellman values to interpolate
#' @param mcyears Vector of monte carlo years to take into account
#'
#' @return List of \code{stats::approxfun} for each scenario
get_bellman_values_interpolation <- function(Data_week,next_week_values,mcyears){

  df_next_week <- data.frame(years = Data_week$years,
                             next_state = Data_week$states,
                             next_value = next_week_values)

  f_next_value <- c()
  for (year in mcyears){
    df <- dplyr::filter(df_next_week, years==year)
    f <- stats::approxfun(df$next_state, df$next_value)#,yleft = 0, yright=0)
    f_next_value <- c(f_next_value,f)
  }

  return(f_next_value)
}

#' Create a data frame with all possible transition and associated next state for
#' each scenario and each state for one particular week, used in \code{Bellman}
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' list of states and years evaluated (we suppose there is only one week at a time)
#' as weel as inflows
#' @param decision_space Simulation constraints values for the week
#'  generated by \code{get_Reward} or \code{runWaterValuesSimulation}
#' @param f_next_value List of approximated Bellman functions for the next week,
#' generated by \code{get_bellman_values_interpolation}
#' @param mcyears Vector of monte carlo years to take into account
#' @param level_high Double, top rule curve for the end of the week in MWh
#' @param level_low Double, bottom rule curve for the end of the week in MWh
#' @param E_max Double, weekly maximum turbining power for the week
#' @param P_max Double, weekly maximum pumping power for the week
#' @param next_week_values Vector of Bellman values for the next week
#' @param niveau_max Reservoir capacity in MWh
#'
#' @return Data frame with same format as Data week with 3 more columns :
#' next_state, control (transition to next state) and
#' next value (Bellman value of next state)
build_all_possible_decisions <- function(Data_week,decision_space,f_next_value,
                                         mcyears,level_high,level_low,E_max,P_max,
                                         next_week_values,niveau_max){

  df_next_week <- data.frame(years = Data_week$years,
                             next_state = Data_week$states,
                             next_value = next_week_values)

  future_states <- Data_week %>%
    dplyr::inner_join(df_next_week,by="years", relationship="many-to-many") %>%
    dplyr::mutate(control = -.data$next_state+states+hydroStorage)

  control_possible <- Data_week  %>%
    dplyr::mutate(control=list(decision_space)) %>%
    tidyr::unnest_longer(.data$control) %>%
    dplyr::mutate(next_state=dplyr::if_else(states+hydroStorage-.data$control>niveau_max,niveau_max,
                              states+hydroStorage-.data$control)) %>%
    dplyr::mutate(next_value=mapply(function(y,x)f_next_value[[which(y==mcyears)]](x), years, .data$next_state))

  control_min <- Data_week %>%
    dplyr::mutate(next_state=level_high) %>%
    dplyr::mutate(control = -.data$next_state+states+hydroStorage) %>%
    dplyr::mutate(next_value=mapply(function(y,x)f_next_value[[which(y==mcyears)]](x), years, .data$next_state))

  control_max <- Data_week %>%
    dplyr::mutate(next_state=level_low) %>%
    dplyr::mutate(control = -.data$next_state+states+hydroStorage) %>%
    dplyr::mutate(next_value=mapply(function(y,x)f_next_value[[which(y==mcyears)]](x), years, .data$next_state))

  df_SDP <- dplyr::bind_rows(future_states, control_possible, control_min, control_max) %>%
    dplyr::filter((-P_max<=.data$control)&(.data$control<=E_max)&(.data$next_state>=0))

  return(df_SDP)
}

#' Create a data frame with all possible transition and associated next state for
#' each scenario and each state for one particular week, used in \code{Bellman}.
#' For each next state, Bellman value is calculated.
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' list of states and years evaluated (we suppose there is only one week at a time)
#' as weel as inflows
#' @param decision_space Simulation constraints values for the week
#'  generated by \code{get_Reward} or \code{runWaterValuesSimulation}
#' @param mcyears Vector of monte carlo years to take into account
#' @param lvl_high Double, top rule curve for the end of the week in MWh
#' @param lvl_low Double, bottom rule curve for the end of the week in MWh
#' @param E_max Double, weekly maximum turbining power for the week
#' @param P_max Double, weekly maximum pumping power for the week
#' @param next_week_values Vector of Bellman values for the next week
#' @param niveau_max Reservoir capacity in MWh
#' @param overflow_cost Cost for overflow (equal to spillage cost of the area)
#' @param next_states possible states for next week
#'
#' @return Data frame with same format as Data week with 3 more columns :
#' next_state, control (transition to next state) and
#' next value (Bellman value of next state)
#' @keywords internal
build_all_possible_decisions <- function(Data_week,
                                         decision_space,
                                         mcyears,
                                         lvl_high, lvl_low,
                                         E_max, P_max,
                                         next_week_values,
                                         niveau_max,
                                         overflow_cost,
                                         next_states = NULL) {
  # 1) future_states
  df_next_week <- dplyr::distinct(data.frame(
    next_state = next_states,
    next_value = next_week_values
  ))

  future_states <- dplyr::cross_join(Data_week, df_next_week) %>%
    dplyr::transmute(
      years,
      states,
      hydroStorage,
      next_state,
      control = - next_state + states + hydroStorage,
      next_value
    )

  # 2) control_possible vectoris√©
  control_possible_raw <- dplyr::right_join(
    Data_week,
    decision_space,
    by = c("years" = "mcYear")
  ) %>%
    dplyr::mutate(
      tmp_next_state = states + hydroStorage - control,
      overflow = pmax(tmp_next_state - niveau_max, 0),
      next_state = pmin(tmp_next_state, niveau_max)) %>%
    dplyr::select(c("years","states","next_state","control","hydroStorage","overflow"))

  # 3) control_min
  control_min <- Data_week %>%
    dplyr::transmute(
      years,
      states,
      hydroStorage,
      next_state = lvl_high,
      control = - lvl_high + states + hydroStorage,
      overflow = 0
    )

  # 4) control_max
  control_max <- Data_week %>%
    dplyr::transmute(
      years,
      states,
      hydroStorage,
      next_state = lvl_low,
      control = - lvl_low + states + hydroStorage,
      overflow = 0
    )

  # 5) state max
  setDT(Data_week)

  delta <- Data_week[, states + hydroStorage - niveau_max]

  state_max <- Data_week[, .(
    years,
    states,
    hydroStorage,
    next_state = niveau_max,
    control  = pmin(delta, E_max),
    overflow = pmax(delta - E_max, 0)
  )]

  # 6) concat + filtre final

  all_controls = dplyr::bind_rows(control_possible_raw, control_min, control_max,state_max)%>%
    dplyr::filter(next_state >= 0)
  setDT(all_controls)
  interp_next_value <- approxfun(df_next_week$next_state, df_next_week$next_value)

  all_controls <- all_controls[, next_value := interp_next_value(next_state)+overflow*overflow_cost][,overflow := NULL]

  dplyr::bind_rows(future_states, all_controls) %>%
    dplyr::filter(control >= -P_max, control <= E_max)
}


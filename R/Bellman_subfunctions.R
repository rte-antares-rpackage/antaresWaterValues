
#' Create approximation of reward function for each scenario, used in \code{Bellman}
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' reward database for each scenario (we suppose there is only one week at a time)
#'
#' @return List of \code{stats::approxfun} for each scenario
#' @keywords internal
get_reward_interpolation <- function(Data_week){

  reward <- dplyr::distinct(Data_week[,c('years','reward_db')])

  f_reward_year <- sapply(reward$reward_db,FUN = function(df) stats::approxfun(df$control,df$reward))

  return(f_reward_year)
}

#' Create approximation of Bellman function for next week for each scenario, used in \code{Bellman} and
#' in \code{getOptimalTrend}
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' list of states and years evaluated (we suppose there is only one week at a time)
#' @param next_week_values Vector of Bellman values to interpolate
#' @param mcyears Vector of monte carlo years to take into account
#'
#' @return List of \code{stats::approxfun} for each scenario
#' @keywords internal
get_bellman_values_interpolation <- function(Data_week,next_week_values,mcyears){

  df_next_week <- data.frame(years = Data_week$years,
                             next_state = Data_week$states,
                             next_value = next_week_values)

  f_next_value <- c()
  for (year in mcyears){
    df <- dplyr::filter(df_next_week, .data$years==year)
    f <- stats::approxfun(df$next_state, df$next_value)#,yleft = 0, yright=0)
    f_next_value <- c(f_next_value,f)
  }

  return(f_next_value)
}

#' Create a data frame with all possible transition and associated next state for
#' each scenario and each state for one particular week, used in \code{Bellman}.
#' For each next state, Bellman value is calculated.
#'
#' @param Data_week Data frame generated in \code{Grid_Matrix} code containing
#' list of states and years evaluated (we suppose there is only one week at a time)
#' as weel as inflows
#' @param decision_space Simulation constraints values for the week
#'  generated by \code{get_Reward} or \code{runWaterValuesSimulation}
#' @param f_next_value List of approximated Bellman functions for the next week,
#' generated by \code{get_bellman_values_interpolation}
#' @param mcyears Vector of monte carlo years to take into account
#' @param lvl_high Double, top rule curve for the end of the week in MWh
#' @param lvl_low Double, bottom rule curve for the end of the week in MWh
#' @param E_max Double, weekly maximum turbining power for the week
#' @param P_max Double, weekly maximum pumping power for the week
#' @param next_week_values Vector of Bellman values for the next week
#' @param niveau_max Reservoir capacity in MWh
#' @param overflow_cost Cost for overflow (equal to spillage cost of the area)
#' @param next_states possible states for next week
#'
#' @return Data frame with same format as Data week with 3 more columns :
#' next_state, control (transition to next state) and
#' next value (Bellman value of next state)
#' @keywords internal
build_all_possible_decisions <- function(Data_week,
                                         decision_space,
                                         f_next_value,
                                         mcyears,
                                         lvl_high, lvl_low,
                                         E_max, P_max,
                                         next_week_values,
                                         niveau_max,
                                         overflow_cost,
                                         next_states = NULL) {

  if (is.null(next_states)) {
    next_states <- Data_week$states
  }

  # Préparer les fonctions pour chaque année MC
  f_list <- setNames(f_next_value, mcyears)

  # 1) future_states
  df_next_week <- tibble::tibble(
    years = Data_week$years,
    next_state = next_states,
    next_value = next_week_values
  )

  future_states <- dplyr::inner_join(Data_week, df_next_week, by="years") %>%
    dplyr::transmute(
      years,
      states,
      hydroStorage,
      next_state,
      control = - next_state + states + hydroStorage,
      next_value
    )

  # 2) control_possible vectorisé
  control_possible_raw <- dplyr::right_join(
    Data_week,
    decision_space,
    by = c("years" = "mcYear")
  ) %>%
    dplyr::mutate(
      control = u,
      tmp_next_state = states + hydroStorage - control,
      overflow = pmax(tmp_next_state - niveau_max, 0),
      next_state = pmin(tmp_next_state, niveau_max),
      next_value = f_list[as.character(years)] %>% purrr::map2_dbl(next_state, ~ .x(.y)) + overflow * overflow_cost
    ) %>%
    dplyr::select(-u, -tmp_next_state)

  # 3) control_min
  control_min <- Data_week %>%
    dplyr::transmute(
      years,
      states,
      hydroStorage,
      next_state = lvl_high,
      control = - lvl_high + states + hydroStorage,
      next_value = purrr::map2_dbl(
        f_list[as.character(years)],
        lvl_high,
        ~ .x(.y)
      )
    )

  # 4) control_max
  control_max <- Data_week %>%
    dplyr::transmute(
      years,
      states,
      hydroStorage,
      next_state = lvl_low,
      control = - lvl_low + states + hydroStorage,
      next_value = purrr::map2_dbl(
        f_list[as.character(years)],
        lvl_low,
        ~ .x(.y)
      )
    )

  # 5) concat + filtre final
  dplyr::bind_rows(future_states, control_possible_raw, control_min, control_max) %>%
    dplyr::filter(control >= -P_max, control <= E_max, next_state >= 0)
}


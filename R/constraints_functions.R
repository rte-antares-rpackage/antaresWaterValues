#' This function disable binding constraints for \code{runWaterValuesSimulation}
#'
#' @param constraint_value the value of the constraint
#' @param name_bc the name of the constraint.
#' @param pumping Boolean. True to take into account the pumping.
#' @param opts
#'   List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param area Area used to calculate watervalues
#'
#' @importFrom antaresEditObject editBindingConstraint
#' @export

disable_constraint <- function(constraint_value,name_bc,pumping=F,opts,area=NULL){

  opts <- antaresEditObject::removeBindingConstraint(name = name_bc, opts = opts)
  opts <- antaresEditObject::removeBindingConstraint(name = paste0("Turb",area), opts = opts)
  if(pumping){
    opts <- antaresEditObject::removeBindingConstraint(name = paste0("Pump",area), opts = opts)
  }
  return(opts)
}








#' This function generate binding constraints for \code{runWaterValuesSimulation}
#'
#' @param constraint_value the value of the constraint
#' @param coeff the sens of the constraint notation in Antares.
#' @param name_constraint the name of the constraint.
#' @param efficiency in [0,1]. efficient ratio of pumping.
#' @param opts
#'   List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param area Area used to calculate watervalues
#'
#' @export


generate_constraints <- function(constraint_value,coeff,name_constraint,efficiency=0.75,opts,area=NULL){


  if(length(coeff)==2){

    opts <-  antaresEditObject::createBindingConstraint(
      name =  paste0("Turb",area),
      enabled = TRUE,
      operator = "greater",
      coefficients = coeff[2],
      opts = opts,
      overwrite = TRUE,
      timeStep = "hourly"
    )

    opts <- antaresEditObject::createBindingConstraint(
      name = name_constraint,
      values = data.frame(less = c(rep(constraint_value, each=7),rep(constraint_value[1],2))),
      enabled = TRUE,
      timeStep = "weekly",
      operator = "less",
      overwrite = TRUE,
      coefficients = coeff[1],
      opts = opts)
  }else{

    # Implement the flow sens in the study Pumping

    opts <- antaresEditObject::createBindingConstraint(
      name = paste0("Pump",area),
      enabled = TRUE,
      operator = "greater",
      coefficients = -coeff[3],
      opts = opts,
      overwrite = TRUE,
      timeStep = "hourly"
    )

    # Implement the flow sens in the study Turbining

    opts <-  antaresEditObject::createBindingConstraint(
      name = paste0("Turb",area),
      enabled = TRUE,
      operator = "greater",
      coefficients = coeff[2],
      opts = opts,
      overwrite = TRUE,
      timeStep = "hourly"
    )



    # Implement binding constraint

    opts <- antaresEditObject::createBindingConstraint(
      name = name_constraint,
      values = data.frame(equal = c(rep(constraint_value, each=7),rep(constraint_value[1],2))),
      enabled = TRUE,
      timeStep = "weekly",
      operator = "equal",
      overwrite = TRUE,
      coefficients = c(coeff[1],efficiency*coeff[3]),
      opts = opts)
  }


  return(opts)
}

#' Generate the list of constraint values of the link between the fictive area and the real one
#' Used to run simulations in \code{runWaterValuesSimulation} and also to estimate reward functions
#' in functions such as \code{Grid_Matrix} and \code{iterations_simulation_DP}
#'
#' @param area The area concerned by the simulation.
#' @param nb_disc_stock Number of constraint values wanted for each week
#' @param pumping Boolean. True to take into account the pumping.
#' @param pumping_efficiency between 0 and 1. the pumping efficiency ratio.
#' @param opts
#'   List of simulation parameters returned by the function \code{antaresRead::setSimulationPath}
#' @param max_hydro weekly pumping and turbining maximum powers, generated by \code{get_max_hydro}
#' @param inflow weekly inflow
#'
#' @export
constraint_generator <- function(area,nb_disc_stock,pumping=F,pumping_efficiency=NULL,opts,max_hydro=NULL,
                                 inflow=NULL)
{



  if(is.null(pumping_efficiency))
  { pumping_efficiency <- getPumpEfficiency(area,opts=opts)}


  if(is.null(max_hydro)){
    max_hydro <- get_max_hydro(area,opts,timeStep = "weekly")
  }
  res_cap <- get_reservoir_capacity(area,opts)
  if (is.null(inflow)){
    inflow <- antaresRead::readInputTS(hydroStorage = area , timeStep="weekly")
  }
  max_app <- inflow %>%
    dplyr::group_by(timeId) %>%
    dplyr::summarise(max_app=max(hydroStorage))
  max_hydro <- left_join(max_hydro,max_app,by=c("timeId"))

  weeks <- dplyr::distinct(max_hydro,timeId)$timeId
  df_constraint <- data.frame(week=weeks)
  df_constraint$u <- sapply(df_constraint$week,
                            FUN = function(w) constraint_week(pumping,pumping_efficiency,nb_disc_stock,res_cap,dplyr::filter(max_hydro,timeId==w)),
                            simplify = F)

  df_constraint <- tidyr::unnest_wider(df_constraint,.data$u,names_sep = "_")
  df_constraint <- df_constraint %>%
    tidyr::pivot_longer(cols=2:length(df_constraint),names_to="sim",values_to="u") %>%
    dplyr::arrange(.data$week,.data$u)

  return(df_constraint)
}


#' Generate constraint values for a week at a time used in \code{constraint_generator}
#' depending on the maximum powers for the week
#'
#' @param pumping Boolean. True to take into account the pumping.
#' @param pumping_efficiency between 0 and 1. the pumping efficiency ratio.
#' @param nb_disc_stock Number of constraint values wanted for each week
#' @param res_cap Double, reservoir capacity
#' @param hydro Pumping and turbining maximum powers for the week, generated by \code{get_max_hydro}
#'
#' @return List of constraint values for the week
constraint_week <- function(pumping,pumping_efficiency,nb_disc_stock,res_cap,hydro){
  maxi <- min(hydro$turb,res_cap+hydro$max_app)
  mini <- -hydro$pump*pumping_efficiency

  if(pumping){
    if(nb_disc_stock<3){
      message("nb_disc_stock should be greater than 2")
      constraint_values <- c(0)
    } else {
      total <- maxi-mini

      pump_rat <- 2
      turb_rat <- 2
      if (nb_disc_stock>=4){
        for (i in 1:(nb_disc_stock+1-4)){
          inc_pump <- abs(abs(mini)/(pump_rat+1)-abs(maxi)/turb_rat)
          inc_turb <- abs(abs(maxi)/(turb_rat+1)-abs(mini)/pump_rat)
          if (inc_pump<inc_turb){
            pump_rat <- pump_rat+1
          } else {
            turb_rat <- turb_rat+1
          }
        }
      }
      constraint_values_pump <- seq(from=mini,to=0,length.out=pump_rat)
      constraint_values_turb <- seq(from=0,to=maxi,length.out=turb_rat)

      constraint_values <- append(constraint_values_pump,constraint_values_turb)
      constraint_values <- constraint_values[!duplicated(constraint_values)]

      constraint_values <- round(constraint_values)
    }


  }else{
    if(nb_disc_stock<2){
      message("nb_disc_stock should be greater than 1")
      constraint_values <- c(0)
    } else {
      constraint_values <- seq(from = 0, to = maxi, length.out = nb_disc_stock)
      constraint_values <- round(constraint_values)
    }

  }
  return(constraint_values)
}

#' Generate coefficients for biding constraints, used in \code{runWaterValuesSimulation}
#'
#' @param area Area with the area
#' @param fictive_area Fictive area involved in the biding contraint
#' @param pumping Boolean. True to take into account the pumping.
#' @param opts List of simulation parameters returned by the function \code{antaresRead::setSimulationPath}
#'
#' @return Named vector of coefficients
generate_link_coeff <- function(area,fictive_area, pumping = FALSE, opts = simOptions()){

  # For the case of the pumping node, the constraint will be applied on the flow from the real area to the pumping node
  if(pumping == TRUE & grepl("_pump$", fictive_area)){
    if (match(area, sort(c(area, fictive_area))) == 1) {
      coeff <- stats::setNames(-1, paste(area, fictive_area, sep = "%"))
    } else {
      coeff <- stats::setNames(1, paste(fictive_area, area, sep = "%"))
    }
  } #Otherwise, the constraint will be applied on the generation from the thermal cluster
  else{
    cluster_desc <- readClusterDesc(opts)
    fictive_cluster <- cluster_desc[area == fictive_area, cluster]
    coeff1 <- stats::setNames(1, paste(fictive_area, fictive_cluster, sep = "."))

    if (match(area, sort(c(area, fictive_area))) == 1) {
      coeff2 <- stats::setNames(-1, paste(area, fictive_area, sep = "%"))
    } else {
      coeff2 <- stats::setNames(1, paste(fictive_area, area, sep = "%"))
    }
    coeff <- c(coeff1, coeff2)
  }

  return(coeff)
}

#' Calculate an optimal trajectory for the reservoir levels based on Bellman values and reward functions.
#'
#' @param level_init Initial level of the reservoir in MWh generated by \code{get_initial_level_year_per_year()}.
#' @param watervalues Data frame aggregated watervalues generated by \code{Grid_Matrix()}.
#' @inheritParams Grid_Matrix
#' @param mix_scenario Should scenario be mix from one week to another ?
#' @param seed If scenario are mixed, seed to make results reproducible.
#' @param penalty_final_level Penalties (for both bottom and top rule curves) to force final level
#' @param reward Output \code{reward} of \code{get_Reward()}
#'
#' @return Data frame with level (\code{"lev"}) and optimal transition
#' (\code{"constraint"}) for each (\code{"week"}) and each (\code{"scenario"}).
#' For each (\code{"week"}), the (\code{"scenario"}) used is given by (\code{"mcYear"}).
getOptimalTrend <- function(level_init,
                            watervalues,
                            mcyears,
                            reservoir_capacity,
                            penalty_low,
                            penalty_high,
                            penalty_final_level,
                            final_level,
                            max_hydro_weekly,
                            seed = 0,
                            efficiency,
                            mix_scenario=TRUE,
                            reward){
  level_i <- data.frame(states = level_init[mcyears],scenario = seq_along(mcyears))
  levels <- data.frame()

  set.seed(seed) # just to make it reproducible

  for (w in 1:52){

    transition <- watervalues %>%
      dplyr::filter(.data$weeks==w+1)

    reward_week = dplyr::filter(reward,.data$timeId==w)

    # Rule curves at the end of the current week (and beginning of the next one)
    Data_week <- watervalues %>%
      dplyr::filter(.data$weeks==w) %>%
      dplyr::filter(.data$statesid == 1)
    Data_week$value_node <- NA_real_
    Data_week$transition <- NA_real_
    Data_week$transition_reward <- NA_real_
    Data_week$next_bellman_value <- NA_real_
    if (mix_scenario){
      Data_week$scenario <- sample(seq_along(mcyears))
    } else {
      Data_week$scenario <- seq_along(mcyears)
    }
    Data_week <- Data_week %>%
      dplyr::select(-c("states")) %>%
      dplyr::left_join(level_i,by=c("scenario"))
    l_high <- ifelse(w<52,Data_week$level_high[1],final_level*reservoir_capacity/100)
    l_low <- ifelse(w<52,Data_week$level_low[1],final_level*reservoir_capacity/100)
    pen_high <- ifelse(w<52,penalty_high,penalty_final_level)
    pen_low <- ifelse(w<52,penalty_low,penalty_final_level)

    control = Bellman(Data_week = Data_week,
                      next_week_values_l = transition$value_node,
                      reward = reward_week,
                      E_max = max_hydro_weekly$turb[w],
                      P_max = max_hydro_weekly$pump[w]*efficiency,
                      mcyears = mcyears,
                      niveau_max = reservoir_capacity,
                      penalty_level_low = pen_low,
                      penalty_level_high = pen_high,
                      lvl_high = l_high,
                      lvl_low = l_low,
                      overflow_cost = 0,
                      next_state = transition$states)

    control <- control %>%
      dplyr::rename("week"="weeks","mcYear"="years","lev"="next_state","constraint"="transition") %>%
      dplyr::select(c("week","mcYear","lev","constraint","scenario")) %>%
      dplyr::distinct(.data$week,.data$mcYear,.keep_all = TRUE)

    assertthat::assert_that(nrow(control)==length(mcyears),msg=paste0("Problem with optimal trend at week ",w))

    levels <- dplyr::bind_rows(levels,control)

    level_i <- dplyr::select(control,c("lev","scenario")) %>%
      dplyr::rename("states"="lev")

  }

  return(levels)
}

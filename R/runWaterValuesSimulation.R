#' Run a simulation for calculating water values for a specific area
#'
#' @param area The area concerned by the simulation.
#' @param simulation_name The name of the simulation, \code{s} is a placeholder for the constraint value defined by \code{nb_disc_stock}.
#' @param nb_disc_stock Number of simulation to launch, a vector of energy constraint
#'  will be created from maximum pumping power to the hydro storage maximum and of length this parameter.
#' @param mcyears Number of Monte Carlo years to simulate or a vector of years indexes to launch.
#  constraint_values Vector of energy constraints on the link between the area and the fictive area.
#' @param path_solver Character containing the Antares Solver path, argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param show_output_on_console Argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param overwrite If area or cluster already exists, should they be overwritten?
#' @param file_name the Rdata file name.
#' @param pumping Boolean. True to take into account the pumping.
#' @param efficiency in [0,1]. efficient ratio of pumping.
#' @param launch_simulations Boolean. True to to run the simulations.
#' @param opts
#'   List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath} or \code{antaresRead::setSimulationPathAPI}
#' @param constraint_values constraint values to use to run simulations, generated by the function \code{\link{constraint_generator}}
#' @param expansion Binary. True if mode expansion was used to run simulations
#'
#' @note This function have side effects on the Antares study used, a fictive area is created and a new district as well.
#'
#' @export
#'

runWaterValuesSimulation <- function(area=NULL,
                                     simulation_name = "wv_sim_%s",
                                     nb_disc_stock = 10,
                                     mcyears = NULL,
                                     path_solver=NULL,
                                     show_output_on_console = FALSE,
                                     overwrite = FALSE,
                                     opts = antaresRead::simOptions(),
                                     file_name=NULL,
                                     pumping=T,
                                     efficiency,
                                     launch_simulations=NULL,
                                     constraint_values=NULL,
                                     expansion=T){

  area = tolower(area)
  check_area_name(area = area, opts = opts)

  backup = getBackupData(area,mcyears,opts)

  # Get max hydro power that can be generated in a week
  if (is.null(constraint_values)){
    constraint_values <- constraint_generator(area=area,nb_disc_stock=nb_disc_stock,
                                              pumping=pumping,
                                              pumping_efficiency = efficiency,
                                              opts=opts, mcyears=mcyears)
  }

  res = setupGeneralParameters(opts,
                               expansion,
                               mcyears,
                               simulation_name,
                               file_name,
                               constraint_values,
                               multistock = F)
  simulation_name = res[[1]]
  file_name = res[[2]]
  constraint_values = res[[3]]
  nb_disc_stock = res[[4]]

  simulation_res <- list()

  #create the fictive areas
  tryCatch({
    opts <- setupWaterValuesSimulation(
      area = area,
      overwrite = overwrite,
      opts = opts,
      pumping=pumping,
      efficiency=efficiency,
      backup = backup
    )

    opts <- setWaterValuesDistrict(opts)

    # Start the simulations

    simulation_names <- vector(mode = "character", length = nb_disc_stock)

    for (i in 1:nb_disc_stock) {
      # Prepare simulation parameters
      name_sim <- dplyr::distinct(constraint_values,.data$sim)$sim[[i]]
      constraint_value <- dplyr::filter(constraint_values,.data$sim==name_sim)

      generate_rhs_bc(constraint_value=constraint_value,area=area,opts=opts)

      sim_name <- paste0(file_name,"_",sprintf(simulation_name, format(
        name_sim, decimal.mark = ",")))
      if(is.null(launch_simulations)){
        launchSimulation(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value)
      }
      else {
        if(launch_simulations[i]){
          launchSimulation(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value)
        }
      }

      clear_scenario_builder(opts)

      simulation_names[i] <- sim_name
    }

    simulation_res <- list(
      simulation_names = simulation_names,
      simulation_values = constraint_values,
      area = area,
      mc_years = mcyears,
      pumping = pumping,
      eff = efficiency,
      expansion = expansion
    )

    if(!is_api_study(opts)){
      save(simulation_res,file=paste0(opts$studyPath,"/user/",file_name,".RData"))
    } else {
      body = list()
      body$file <- jsonlite::toJSON(simulation_res,
                                    auto_unbox = TRUE)
      antaresRead::api_put(opts=opts,endpoint=paste0(opts$study_id,
                                                     "/raw?path=user%2F",file_name,".json&create_missing=true&resource_type=file"),
                           body=body)
    }

  },
  finally = {
    resetStudy(opts,area,pumping,backup)
    clear_scenario_builder(opts)}
  )


  return(simulation_res)
}

setupGeneralParameters <- function(opts,
                                   expansion,
                                   mcyears,
                                   simulation_name,
                                   file_name,
                                   constraint_values,
                                   multistock){

  #check the study is well selected
  assertthat::assert_that(class(opts) == "simOptions")

  assertthat::assert_that(is.numeric(mcyears)==TRUE)

  # check the name format
  simulation_name <- tolower(simulation_name)
  if(!endsWith(simulation_name,"_%s")){
    simulation_name <- paste0(simulation_name,"_%s")
  }

  file_name = tolower(file_name)

  antaresEditObject::setPlaylist(playlist = mcyears,opts = opts)

  # Activate output year by year
  antaresEditObject::updateGeneralSettings(year.by.year = TRUE, opts = opts)

  # Adjust thematic trimming
  settings_ini <- antaresRead::readIni(file.path("settings", "generaldata"),
                                        opts=opts)
  if (settings_ini$general$`thematic-trimming`){
    if (!is_api_study(opts)) {
      for (p in list("OV. COST","MRG. PRICE","BALANCE")){
        if (p %in% settings_ini$`variables selection`){
          idx <- which(settings_ini$`variables selection`== p)
          settings_ini$`variables selection`[[idx]] <- NULL
        }
        settings_ini$`variables selection` <- append(settings_ini$`variables selection`,
                                                      list(`select_var +`=p))
      }
    } else {
      variable = unique(c(stringr::str_remove(stringr::str_remove(unlist(stringr::str_split(settings_ini$`variables selection`$`select_var +`,"\',\'")),"\\[\'"),"\'\\]"),
                          "OV. COST","MRG. PRICE","BALANCE"))
      new_variable_selection = paste0("[\'", stringr::str_flatten(variable,collapse = "\',\'"), "\']")
      settings_ini$`variables selection`$`select_var +` = new_variable_selection
    }
    antaresEditObject::writeIni(settings_ini,
                                file.path("settings", "generaldata"),
                                overwrite=T,
                                opts=opts)
  }

  if ("mcYear" %in% names(constraint_values)){
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$mcYear %in% mcyears, .data$week %in% 1:52)
    assertthat::assert_that(opts$antaresVersion>=870,
                            msg = "Scenarization of rhs of binding constraints not available with the version of Antares. Update the study to 8.7.0 or don't scenarize control values.")
    if (multistock){
      constraint_values <- constraint_values %>%
        dplyr::select(c("mcYear","week","u","sim","area"))
    } else {
      constraint_values <- constraint_values %>%
        dplyr::select(c("mcYear","week","u","sim"))
    }
  } else {
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$week %in% 1:52)
    if (multistock){
      constraint_values <- constraint_values %>%
        dplyr::select(c("week","u","sim","area"))
    } else {
      constraint_values <- constraint_values %>%
        dplyr::select(c("week","u","sim"))
    }
  }
  nb_disc_stock <- dplyr::n_distinct(constraint_values$sim)

  return(list(simulation_name,file_name,constraint_values,nb_disc_stock))

}

#' Reset an Antares study. In case, there is a problem when executing \code{runWaterValuesSimulation},
#' run this function to restore the study.
#'
#' @param opts  List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param area The area concerned by the simulation
#' @param pumping Boolean. True to take into account the pumping.
#' @param backup List with hydro_storage, load and misc_gen backups for area
#' generated by the function \code{getBackupData}
#'
#' @export
resetStudy <- function(opts, area, pumping,
                       backup){
  message(paste0("Please, don't interupt ! Area '",area,"' is being reset."))
  fictive_area <- paste0("watervalue_", area)

  disable_constraint(opts,pumping,area = area)

  fictive_areas <- c(paste0(fictive_area,"_turb"))

  if(pumping){
    fictive_areas <- c(fictive_areas,paste0(fictive_area,"_pump"))
  }

  for (fictive_area in fictive_areas){
    if (fictive_area %in% opts$areaList){
      suppressWarnings(antaresEditObject::removeArea(fictive_area,opts = opts))
    }
  }

  restoreHydroStorage(area = area, opts = opts, data=backup$hydro_storage)
  restore_fictive_fatal_prod_demand(area = area, opts = opts, load = backup$load,
                                    misc_gen = backup$misc_gen)
}

#' Run a simulation for calculating water values for a specific area
#'
#' @param simulation_name The name of the simulation, \code{s} is a placeholder for the constraint value defined by \code{nb_disc_stock}.
#' @param mcyears Number of Monte Carlo years to simulate or a vector of years indexes to launch.
#' @param path_solver Character containing the Antares Solver path, argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param show_output_on_console Argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param overwrite If area or cluster already exists, should they be overwritten?
#' @param file_name the Rdata file name.
#' @param launch_simulations Boolean. True to to run the simulations.
#' @param opts
#'   List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param simulation_name character
#' @param constraint_values constraint values to use to run simulations, generated by the function \code{\link{constraint_generator}}
#' @param list_areas List of areas concerned by the simulation.
#' @param list_pumping List of bools to tell if pumping is available in areas
#' @param list_efficiency List of pumping efficiency
#' @param expansion Binary. True if mode expansion was used to run simulations
#'
#' @note This function have side effects on the Antares study used, a fictive area is created and a new district as well.
#'
#' @export
#'

runWaterValuesSimulationMultiStock <- function(list_areas,
                                               list_pumping,
                                               list_efficiency,
                                     simulation_name = "wv_sim_%s",
                                     mcyears = NULL,
                                     path_solver=NULL,
                                     show_output_on_console = FALSE,
                                     overwrite = FALSE,
                                     opts = antaresRead::simOptions(),
                                     file_name=NULL,
                                     launch_simulations=NULL,
                                     constraint_values=NULL,
                                     expansion=T){
  list_areas = tolower(list_areas)

  list_backup = list()
  for (j in 1:length(list_areas)){
    area = list_areas[[j]]
    check_area_name(area = area, opts = opts)

    list_backup[[j]] = getBackupData(area,mcyears,opts)
  }

  res = setupGeneralParameters(opts,
                               expansion,
                               mcyears,
                               simulation_name,
                               file_name,
                               constraint_values,
                               multistock = T)
  simulation_name = res[[1]]
  file_name = res[[2]]
  constraint_values = res[[3]]
  nb_disc_stock = res[[4]]

  simulation_res <- list()

  tryCatch({
    for (j in 1:length(list_areas)){
      area <- list_areas[[j]]

      opts <- setupWaterValuesSimulation(
        area = area,
        overwrite = overwrite,
        opts = opts,
        pumping=list_pumping[[j]],
        efficiency=list_efficiency[[j]],
        backup = list_backup[[j]]
      )

    }

    opts <- setWaterValuesDistrict(opts)

    # Start the simulations

    simulation_names <- vector(mode = "character", length = nb_disc_stock)

    for (i in 1:nb_disc_stock) {
      # Prepare simulation parameters
      name_sim <- dplyr::distinct(constraint_values,.data$sim)$sim[[i]]

      for (j in 1:length(list_areas)){
        constraint_value <- dplyr::filter(constraint_values,.data$sim==name_sim,
                                          .data$area==list_areas[[j]]) %>%
          dplyr::select(-c("area"))

        generate_rhs_bc(constraint_value=constraint_value,area=list_areas[[j]],
                        opts=opts)
      }


      sim_name <- paste0(file_name,"_",sprintf(simulation_name, format(
        name_sim, decimal.mark = ",")))
      if(is.null(launch_simulations)){
        launchSimulation(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value)
      } else{
        if (launch_simulations[i]){
          launchSimulation(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value)
        }
      }
      simulation_names[i] <- sim_name

      clear_scenario_builder(opts)

    }

    simulation_res <- list(
      simulation_names = simulation_names,
      simulation_values = constraint_values,
      list_areas = list_areas,
      mc_years = mcyears,
      list_pumping = list_pumping,
      list_eff = list_efficiency,
      expansion = expansion
    )

    if(!is_api_study(opts)){
      save(simulation_res,file=paste0(opts$studyPath,"/user/",file_name,".RData"))
    } else {
      body = list()
      body$file <- jsonlite::toJSON(simulation_res,
                               auto_unbox = TRUE)
      antaresRead::api_put(opts=opts,endpoint=paste0(opts$study_id,
        "/raw?path=user%2F",file_name,".json&create_missing=true&resource_type=file"),
        body=body)
    }
  },
  finally = {
    for (j in 1:length(list_areas)){
      area = list_areas[[j]]
      resetStudy(opts,area,list_pumping[area],list_backup[[j]])
    }
    clear_scenario_builder(opts)
  }
  )

  return(simulation_res)

}

#' Generate backup data for area
#'
#' @param area Character
#' @param mcyears Monte Carlo years to simulate or a vector of years indexes to launch.
#' @param opts
#' List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#'
#' @return List with hydro_storage, load and misc_gen backups for area
#' @export
getBackupData <- function(area,
                          mcyears,
                          opts){
  backup <- list()
  hydro_storage <- fread_antares(file = file.path(opts$inputPath, "hydro", "series", area, "mod.txt"),
                                               opts = opts)
  if (nrow(hydro_storage)==0){
    message("Hydro storage is empty")
    hydro_storage = matrix(rep(0,365),ncol=1)
  }
  backup$hydro_storage = hydro_storage

  load <- fread_antares(file = file.path(opts$inputPath,"load", "series", paste0("load_",area,".txt")),
                                      opts=opts)
  if (nrow(load)==0){
    message("Load is empty")
    load = matrix(rep(0,8760),ncol=1)
  }
  backup$load = load

  misc_gen <- fread_antares(file = file.path(opts$inputPath, "misc-gen", paste0("miscgen-",area,".txt")),
                                          opts=opts)
  if (nrow(misc_gen)==0){
    message("Misc gen is empty")
    misc_gen = matrix(rep(0,8*8760),ncol=8)
  }
  backup$misc_gen = misc_gen
  return(backup)
}


#' Launch the simulation
#'
#' @param sim_name Character. The name of the simulation.
#' @param i Integer. Number of simulation.
#' @param path_solver Character containing the Antares Solver path, argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param show_output_on_console Argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param opts
#'   List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param expansion Binary. True if mode expansion was used to run simulations
#' @param constraint_value Data.frame {week,sim,u}
launchSimulation <- function(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value){
  message("#  ------------------------------------------------------------------------")
  message(paste0("Running simulation: ", i, " - ", sim_name))
  message("#  ------------------------------------------------------------------------")
  # run the simulation
  if (!is_api_study(opts)){
    assertthat::assert_that(stringr::str_detect(path_solver,"solver.exe$"),
          msg = "Path solver is not the solver executable of Antares.")
  }
  status = antaresEditObject::runSimulation(
    name = sim_name,
    mode = if (!expansion){"economy"}else{"expansion"},
    path_solver = path_solver,
    show_output_on_console = show_output_on_console,
    opts = opts
  )
  if (is_api_study(opts)){
    assertthat::assert_that(status$status == "success")
    if (expansion){
      antaresEditObject::updateGeneralSettings(mode = "economy",opts=opts)
    }
  } else {
    assertthat::assert_that(status == 0)
  }
  if ("mcYear" %in% colnames(constraint_value) & !is_api_study(opts)){
    opts_sim = antaresRead::setSimulationPath(opts$studyPath,simulation=sim_name)
    ts_number = read.csv(paste0(opts_sim$simPath,"/ts-numbers/bindingconstraints/watervalues.txt"))
    scenarios = unique(constraint_value$mcYear)
    assertthat::assert_that(all(ts_number[scenarios,1] == 1:length(scenarios)))
  }
}

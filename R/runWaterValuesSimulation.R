#' Run Antares simulations in order to compute water values for a specific area
#'
#' \code{nb_disc_stock} simulations are run. Each simulation evaluates the cost of a specific control for each week and each scenario.
#' A control is the difference between initial level and final level on a week.
#' Results of simulations can be used to compute reward function with \code{get_Reward()} and then to compute water values with \code{Grid_Matrix()}.
#' See \code{vignette("computation_watervalues")} for more details.
#'
#' To implement a specific control of the storage in Antares the study is modified : \itemize{
#' \item{The hydro object is deactivated by setting inflows to 0 and set \code{reservoir_management} to \code{FALSE}.}
#' \item{Two fictive areas representing pumping and generating are created and linked to \code{area}. The fictive area for pumping has a high enough load with unsupplied cost of 0. The fictive area for generating has a thermal cluster with marginal cost 0.}
#' \item{A weekly binding constraint is created imposing that the difference between the flow coming from generating fictive area and the flow going to pumping fictive area multiplied to the pumping efficiency is equal to the control.}
#' }
#' At the end of simulations, the study is reset.
#'
#' @param area Character. The Antares area concerned by water values computation.
#' @param simulation_name Character. The name of the simulation, \code{s} is a placeholder for the constraint value defined by \code{nb_disc_stock}.
#' @param nb_disc_stock Integer. Number of simulations to launch, \code{nb_disc_stock} different controls values
#'  will be generated from maximum pumping power to maximum generating pumping with \code{constraint_generator()}. Each control values will be evaluated with a simulation.
#' @param mcyears Vector of integer. Monte Carlo years used to compute water values.
#' @param path_solver Character containing the Antares Solver path, argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param show_output_on_console Argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param overwrite If area or cluster already exists, should they be overwritten?
#' @param file_name the Rdata file name.
#' @param pumping Boolean. True to take into account the pumping capacity.
#' @param efficiency Double between 0 and 1. Pumping efficiency ratio. Get it with \code{getPumpEfficiency()}.
#' @param launch_simulations Boolean or vector of booleans with the same length as \code{nb_disc_stock}. True to to run the simulations.
#' @param opts List of study parameters returned by the function \code{antaresRead::setSimulationPath(simulation="input")} in input mode.
#' @param constraint_values Constraint values to use to run simulations, generated by the function \code{\link{constraint_generator}} instead of parameter \code{nb_disc_stock}.
#' @param expansion Binary. True if mode expansion (ie linear relaxation) of Antares is used to run simulations, argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' It is recommended to use mode expansion, it will be faster (only one iteration is done) and results will be smoother as the cost result will correspond to the linear relaxation of the problem.
#'
#' @seealso \code{runWaterValuesSimulationMultiStock()}
#'
#' @returns
#' \item{simulation_names}{Vector of character. Names of simulations.}
#' \item{simulation_values}{A \code{dplyr::tibble()} generated by \code{constraint_generator()} describing controls for each simulation.}
#' \item{area}{Parameter \code{area}.}
#' \item{mcyears}{Parameter \code{mcyears}.}
#' \item{pumping}{Parameter \code{pumping}.}
#' \item{efficiency}{Parameter \code{efficiency}.}
#' \item{expansion}{Parameter \code{expansion}.}
#' \item{fictive_areas}{Parameter \code{fictive_areas}.}
#'
#' @export
#'

runWaterValuesSimulation <- function(area=NULL,
                                     simulation_name = "wv_sim_%s",
                                     nb_disc_stock = 10,
                                     mcyears = NULL,
                                     path_solver=NULL,
                                     show_output_on_console = FALSE,
                                     overwrite = FALSE,
                                     opts,
                                     file_name=NULL,
                                     pumping=TRUE,
                                     efficiency,
                                     launch_simulations=NULL,
                                     constraint_values=NULL,
                                     expansion=TRUE){

  area = tolower(area)
  check_area_name(area = area, opts = opts)

  backup = getBackupData(area,mcyears,opts)

  # Get max hydro power that can be generated in a week
  if (is.null(constraint_values)){
    constraint_values <- constraint_generator(area=area,nb_disc_stock=nb_disc_stock,
                                              pumping=pumping,
                                              efficiency = efficiency,
                                              opts=opts, mcyears=mcyears)
  }

  res = setupGeneralParameters(opts,
                               expansion,
                               mcyears,
                               simulation_name,
                               file_name,
                               constraint_values,
                               multistock = FALSE)
  simulation_name = res[[1]]
  file_name = res[[2]]
  constraint_values = res[[3]]
  nb_disc_stock = res[[4]]

  simulation_res <- list()

  #create the fictive areas
  tryCatch({
    opts <- setupWaterValuesSimulation(
      area = area,
      overwrite = overwrite,
      opts = opts,
      pumping=pumping,
      efficiency=efficiency,
      backup = backup
    )

    opts <- setWaterValuesDistrict(opts)

    # Start the simulations

    simulation_names <- vector(mode = "character", length = nb_disc_stock)

    for (i in 1:nb_disc_stock) {
      # Prepare simulation parameters
      name_sim <- dplyr::distinct(constraint_values,.data$sim)$sim[[i]]
      constraint_value <- dplyr::filter(constraint_values,.data$sim==name_sim)

      generate_rhs_bc(constraint_value=constraint_value,area=area,opts=opts)

      sim_name <- paste0(file_name,"_",sprintf(simulation_name, format(
        name_sim, decimal.mark = ",")))
      if(is.null(launch_simulations)){
        launchSimulation(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value)
      }
      else {
        if(launch_simulations[i]){
          launchSimulation(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value)
        }
      }

      clear_scenario_builder(opts)

      simulation_names[i] <- sim_name
    }

    simulation_res <- list(
      simulation_names = simulation_names,
      simulation_values = constraint_values,
      area = area,
      mcyears = mcyears,
      pumping = pumping,
      efficiency = efficiency,
      expansion = expansion
    )

    if(!is_api_study(opts)){
      save(simulation_res,file=paste0(opts$studyPath,"/user/",file_name,".RData"))
    } else {
      body = list()
      body$file <- jsonlite::toJSON(simulation_res,
                                    auto_unbox = TRUE)
      antaresRead::api_put(opts=opts,endpoint=paste0(opts$study_id,
                                                     "/raw?path=user%2F",file_name,".json&create_missing=true&resource_type=file"),
                           body=body)
    }

  },
  error = function(e) {
    stop(e)
  },
  finally = {
    resetStudy(opts,area,pumping,backup)
    clear_scenario_builder(opts)}
  )


  return(simulation_res)
}

setupGeneralParameters <- function(opts,
                                   expansion,
                                   mcyears,
                                   simulation_name,
                                   file_name,
                                   constraint_values,
                                   multistock){

  #check the study is well selected
  assertthat::assert_that(class(opts) == "simOptions")

  assertthat::assert_that(is.numeric(mcyears)==TRUE)

  # check the name format
  simulation_name <- tolower(simulation_name)
  if(!endsWith(simulation_name,"_%s")){
    simulation_name <- paste0(simulation_name,"_%s")
  }

  file_name = tolower(file_name)

  antaresEditObject::setPlaylist(playlist = mcyears,opts = opts)

  # Activate output year by year
  antaresEditObject::updateGeneralSettings(year.by.year = TRUE, opts = opts)

  # Adjust thematic trimming
  settings_ini <- antaresRead::readIni(file.path("settings", "generaldata"),
                                        opts=opts)
  if (settings_ini$general$`thematic-trimming`){
    if (!is_api_study(opts)) {
      for (p in list("OV. COST","MRG. PRICE","BALANCE")){
        if (p %in% settings_ini$`variables selection`){
          idx <- which(settings_ini$`variables selection`== p)
          settings_ini$`variables selection`[[idx]] <- NULL
        }
        settings_ini$`variables selection` <- append(settings_ini$`variables selection`,
                                                      list(`select_var +`=p))
      }
    } else {
      variable = unique(c(stringr::str_remove(stringr::str_remove(unlist(stringr::str_split(settings_ini$`variables selection`$`select_var +`,"\',\'")),"\\[\'"),"\'\\]"),
                          "OV. COST","MRG. PRICE","BALANCE"))
      new_variable_selection = paste0("[\'", stringr::str_flatten(variable,collapse = "\',\'"), "\']")
      settings_ini$`variables selection`$`select_var +` = new_variable_selection
    }
    antaresEditObject::writeIni(settings_ini,
                                file.path("settings", "generaldata"),
                                overwrite=TRUE,
                                opts=opts)
  }

  if ("mcYear" %in% names(constraint_values)){
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$mcYear %in% mcyears, .data$week %in% 1:52)
    assertthat::assert_that(opts$antaresVersion>=870,
                            msg = "Scenarization of rhs of binding constraints not available with the version of Antares. Update the study to 8.7.0 or don't scenarize control values.")
    if (multistock){
      constraint_values <- constraint_values %>%
        dplyr::select(c("mcYear","week","u","sim","area"))
    } else {
      constraint_values <- constraint_values %>%
        dplyr::select(c("mcYear","week","u","sim"))
    }
  } else {
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$week %in% 1:52)
    if (multistock){
      constraint_values <- constraint_values %>%
        dplyr::select(c("week","u","sim","area"))
    } else {
      constraint_values <- constraint_values %>%
        dplyr::select(c("week","u","sim"))
    }
  }
  nb_disc_stock <- dplyr::n_distinct(constraint_values$sim)

  return(list(simulation_name,file_name,constraint_values,nb_disc_stock))
}

#' Reset an Antares study. In case, there is a problem when executing \code{runWaterValuesSimulation()},
#' run this function to restore the study.
#'
#' @inheritParams runWaterValuesSimulation
#' @param backup List with hydro_storage, load and misc_gen backups for area
#' generated by the function \code{getBackupData()}
#'
#' @keywords internal
resetStudy <- function(opts, area, pumping,
                       backup){
  message(paste0("Please, don't interupt ! Area '",area,"' is being reset."))
  fictive_area <- paste0("watervalue_", area)

  disable_constraint(opts,pumping,area = area)

  fictive_areas <- c(paste0(fictive_area,"_turb"))

  if(pumping){
    fictive_areas <- c(fictive_areas,paste0(fictive_area,"_pump"))
  }

  for (fictive_area in fictive_areas){
    if (fictive_area %in% opts$areaList){
      suppressWarnings(antaresEditObject::removeArea(fictive_area,opts = opts))
    }
  }

  restoreHydroStorage(area = area, opts = opts, data=backup$hydro_storage)
  restore_fictive_fatal_prod_demand(area = area, opts = opts, load = backup$load,
                                    misc_gen = backup$misc_gen)
}

#' Run Antares simulations in order to compute water values for multiple areas
#'
#' Each simulation evaluates for each week and each scenario the cost of a set of controls for all areas in \code{list_areas}.
#'
#' @inheritParams runWaterValuesSimulation
#' @param constraint_values Constraint values for each area to use to run simulations, generated by the function \code{\link{constraint_generator}} with an additional column \code{"area"}.
#' @param list_areas Vector of areas concerned by simulations.
#' @param list_pumping Named vector of binary to tell if pumping is available in areas.
#' @param list_efficiency Named vector of pumping efficiency.
#'
#' @seealso \code{runWaterValuesSimulation()}
#' @returns
#' \item{simulation_names}{Vector of character. Names of simulations.}
#' \item{simulation_values}{A \code{dplyr::tibble()} generated by \code{constraint_generator()} describing controls for each simulation.}
#' \item{list_areas}{Parameter \code{list_areas}.}
#' \item{mcyears}{Parameter \code{mcyears}.}
#' \item{list_pumping}{Parameter \code{list_pumping}.}
#' \item{list_efficiency}{Parameter \code{list_efficiency}.}
#' \item{expansion}{Parameter \code{expansion}.}
#'
#' @export
runWaterValuesSimulationMultiStock <- function(list_areas,
                                               list_pumping,
                                               list_efficiency,
                                     simulation_name = "wv_sim_%s",
                                     mcyears = NULL,
                                     path_solver=NULL,
                                     show_output_on_console = FALSE,
                                     overwrite = FALSE,
                                     opts,
                                     file_name=NULL,
                                     launch_simulations=NULL,
                                     constraint_values=NULL,
                                     expansion=TRUE){
  list_areas = tolower(list_areas)

  list_backup = list()
  for (j in seq_along(list_areas)){
    area = list_areas[[j]]
    check_area_name(area = area, opts = opts)

    list_backup[[j]] = getBackupData(area,mcyears,opts)
  }

  res = setupGeneralParameters(opts,
                               expansion,
                               mcyears,
                               simulation_name,
                               file_name,
                               constraint_values,
                               multistock = TRUE)
  simulation_name = res[[1]]
  file_name = res[[2]]
  constraint_values = res[[3]]
  nb_disc_stock = res[[4]]

  simulation_res <- list()

  tryCatch({
    for (j in seq_along(list_areas)){
      area <- list_areas[[j]]

      opts <- setupWaterValuesSimulation(
        area = area,
        overwrite = overwrite,
        opts = opts,
        pumping=list_pumping[[j]],
        efficiency=list_efficiency[[j]],
        backup = list_backup[[j]]
      )

    }

    opts <- setWaterValuesDistrict(opts)

    # Start the simulations

    simulation_names <- vector(mode = "character", length = nb_disc_stock)

    for (i in 1:nb_disc_stock) {
      # Prepare simulation parameters
      name_sim <- dplyr::distinct(constraint_values,.data$sim)$sim[[i]]

      for (j in seq_along(list_areas)){
        constraint_value <- dplyr::filter(constraint_values,.data$sim==name_sim,
                                          .data$area==list_areas[[j]]) %>%
          dplyr::select(-c("area"))

        generate_rhs_bc(constraint_value=constraint_value,area=list_areas[[j]],
                        opts=opts)
      }


      sim_name <- paste0(file_name,"_",sprintf(simulation_name, format(
        name_sim, decimal.mark = ",")))
      if(is.null(launch_simulations)){
        launchSimulation(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value)
      } else{
        if (launch_simulations[i]){
          launchSimulation(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value)
        }
      }
      simulation_names[i] <- sim_name

      clear_scenario_builder(opts)

    }

    simulation_res <- list(
      simulation_names = simulation_names,
      simulation_values = constraint_values,
      list_areas = list_areas,
      mcyears = mcyears,
      list_pumping = list_pumping,
      list_eff = list_efficiency,
      expansion = expansion
    )

    if(!is_api_study(opts)){
      save(simulation_res,file=paste0(opts$studyPath,"/user/",file_name,".RData"))
    } else {
      body = list()
      body$file <- jsonlite::toJSON(simulation_res,
                               auto_unbox = TRUE)
      antaresRead::api_put(opts=opts,endpoint=paste0(opts$study_id,
        "/raw?path=user%2F",file_name,".json&create_missing=true&resource_type=file"),
        body=body)
    }
  },
  error = function(e) {
    stop(e)
  },
  finally = {
    for (j in seq_along(list_areas)){
      area = list_areas[[j]]
      resetStudy(opts,area,list_pumping[area],list_backup[[j]])
    }
    clear_scenario_builder(opts)
  }
  )

  return(simulation_res)

}

#' Generate backup data for area
#'
#' @inheritParams runWaterValuesSimulation
#'
#' @return List with hydro_storage, load and misc_gen backups for area
#' @keywords internal
getBackupData <- function(area,
                          mcyears,
                          opts){
  backup <- list()
  hydro_storage <- fread_antares(file = file.path(opts$inputPath, "hydro", "series", area, "mod.txt"),
                                               opts = opts)
  if (nrow(hydro_storage)==0){
    message("Hydro storage is empty")
    hydro_storage = matrix(rep(0,365),ncol=1)
  }
  backup$hydro_storage = hydro_storage

  load <- fread_antares(file = file.path(opts$inputPath,"load", "series", paste0("load_",area,".txt")),
                                      opts=opts)
  if (nrow(load)==0){
    message("Load is empty")
    load = matrix(rep(0,8760),ncol=1)
  }
  backup$load = load

  misc_gen <- fread_antares(file = file.path(opts$inputPath, "misc-gen", paste0("miscgen-",area,".txt")),
                                          opts=opts)
  if (nrow(misc_gen)==0){
    message("Misc gen is empty")
    misc_gen = matrix(rep(0,8*8760),ncol=8)
  }
  backup$misc_gen = misc_gen
  return(backup)
}


#' Launch the simulation
#'
#' @param sim_name Character. The name of the simulation.
#' @param i Integer. Number of simulation.
#' @inheritParams runWaterValuesSimulation
#' @keywords internal
launchSimulation <- function(opts,i,sim_name,path_solver,expansion,show_output_on_console,constraint_value){
  message("#  ------------------------------------------------------------------------")
  message(paste0("Running simulation: ", i, " - ", sim_name))
  message("#  ------------------------------------------------------------------------")
  # run the simulation
  if (!is_api_study(opts)){
    assertthat::assert_that(stringr::str_detect(path_solver,"solver.exe$"),
          msg = "Path solver is not the solver executable of Antares.")
  }
  status = antaresEditObject::runSimulation(
    name = sim_name,
    mode = if (!expansion){"economy"}else{"expansion"},
    path_solver = path_solver,
    show_output_on_console = show_output_on_console,
    opts = opts
  )
  if (is_api_study(opts)){
    assertthat::assert_that(status$status == "success",
                            msg = "Antares simulation failed, check Antares logs.")
    if (expansion){
      antaresEditObject::updateGeneralSettings(mode = "economy",opts=opts)
    }
  } else {
    assertthat::assert_that(status == 0,
                            msg = "Antares simulation failed, check Antares logs.")
  }
  if ("mcYear" %in% colnames(constraint_value) && !is_api_study(opts) && 
   !expansion && opts$parameters$output$storenewset){
    opts_sim = antaresRead::setSimulationPath(opts$studyPath,simulation=sim_name)
    ts_number = utils::read.csv(paste0(opts_sim$simPath,"/ts-numbers/bindingconstraints/watervalues.txt"))
    scenarios = unique(constraint_value$mcYear)
    assertthat::assert_that(all(ts_number[scenarios,1] == seq_along(scenarios)))
  }
}

#' Run Antares simulations in order to compute water values for a specific area
#'
#' \code{nb_disc_stock} simulations are run. Each simulation evaluates the cost of a specific control for each week and each scenario.
#' A control is the difference between initial level and final level on a week.
#' Results of simulations can be used to compute reward function with \code{get_Reward()} and then to compute water values with \code{Grid_Matrix()}.
#' See \code{vignette("computation_watervalues")} for more details.
#'
#' To implement a specific control of the storage in Antares the study is modified : \itemize{
#' \item{The hydro object is deactivated by setting inflows to 0 and set \code{reservoir_management} to \code{FALSE}.}
#' \item{Two fictive areas representing pumping and generating are created and linked to \code{area}. The fictive area for pumping has a high enough load with unsupplied cost of 0. The fictive area for generating has a thermal cluster with marginal cost 0.}
#' \item{A weekly binding constraint is created imposing that the difference between the flow coming from generating fictive area and the flow going to pumping fictive area multiplied to the pumping efficiency is equal to the control.}
#' }
#' At the end of simulations, the study is reset.
#'
#' @param area Character. The Antares area concerned by water values computation.
#' @param simulation_name Character. The name of the simulation, \code{s} is a placeholder for the constraint value defined by \code{nb_disc_stock}.
#' @param nb_disc_stock Integer. Number of simulations to launch, \code{nb_disc_stock} different controls values
#'  will be generated from maximum pumping power to maximum generating pumping with \code{constraint_generator()}. Each control values will be evaluated with a simulation.
#' @param mcyears Vector of integer. Monte Carlo years used to compute water values.
#' @param binding_constraint Character. Name of the binding constraint.
#' @param fictive_area Name of the fictive area to create, argument passed to \code{\link{setupWaterValuesSimulation}}.
#' @param thermal_cluster Name of the thermal cluster to create, argument passed to \code{\link{setupWaterValuesSimulation}}.
#' @param path_solver Character containing the Antares Solver path, argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param wait Argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param show_output_on_console Argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param overwrite If area or cluster already exists, should they be overwritten?
#' @param link_from area that will be linked to the created fictive area. If it's
#' \code{NULL} it will takes the area concerned by the simulation.
#' @param otp_dest the path in which the script save Rdata file.
#' @param file_name the Rdata file name.
#' @param remove_areas 	Character vector of area(s) to remove from the created district.
#' @param shiny Boolean. True to run the script in shiny mod.
#' @param pumping Boolean. True to take into account the pumping capacity.
#' @param efficiency Double between 0 and 1. Pumping efficiency ratio. Get it with \code{getPumpEfficiency()}.
#' @param launch_simulations Boolean. True to to run the simulations.
#' @param reset_hydro Boolean. True to reset hydro inflow to 0 before the simulation.
#' @param opts List of study parameters returned by the function \code{antaresRead::setSimulationPath(simulation="input")} in input mode.
#' @param constraint_values Constraint values to use to run simulations, generated by the function \code{\link{constraint_generator}} instead of parameter \code{nb_disc_stock}.
#' @param expansion Binary. True if mode expansion (ie linear relaxation) of Antares is used to run simulations, argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' It is recommended to use mode expansion, it will be faster (only one iteration is done) and results will be smoother as the cost result will correspond to the linear relaxation of the problem.
#'
#' @seealso \code{runWaterValuesSimulationMultiStock()}
#'
#' @returns
#' \item{simulation_names}{Vector of character. Names of simulations.}
#' \item{simulation_values}{A \code{dplyr::tibble()} generated by \code{constraint_generator()} describing controls for each simulation.}
#' \item{area}{Parameter \code{area}.}
#' \item{mc_years}{Parameter \code{mcyears}.}
#' \item{pumping}{Parameter \code{pumping}.}
#' \item{eff}{Parameter \code{efficiency}.}
#' \item{expansion}{Parameter \code{expansion}.}
#' \item{fictive_areas}{Parameter \code{fictive_areas}.}
#'
#' @export
runWaterValuesSimulation <- function(area,
                                     simulation_name = "wv_sim_%s",
                                     nb_disc_stock = 10,
                                     mcyears = NULL,
                                     binding_constraint = "weekly_water_amount",
                                     fictive_area = NULL,
                                     thermal_cluster = NULL,
                                     path_solver=NULL,
                                     wait = TRUE,
                                     show_output_on_console = FALSE,
                                     overwrite = FALSE,
                                     link_from=NULL,
                                     remove_areas=NULL,
                                     opts = antaresRead::simOptions(),
                                     shiny=F,otp_dest=NULL,file_name=NULL,
                                     pumping=F,
                                     efficiency=NULL,
                                     launch_simulations=T,
                                     reset_hydro=T,
                                     constraint_values=NULL,
                                     expansion=T){


  area = tolower(area)
  binding_constraint = tolower(binding_constraint)


  #check the study is well selected
  assertthat::assert_that(class(opts) == "simOptions")

  fictive_areas <- area

  # check the name format

  simulation_name <- tolower(simulation_name)
  if(!endsWith(simulation_name,"_%s")){
    simulation_name <- paste0(simulation_name,"_%s")
  }

  file_name = tolower(file_name)
  if (!stringr::str_detect(file_name,area)){
    file_name <- paste0(area,"_",file_name)
  }


  disable_constraint(binding_constraint,opts,pumping,area = area)
  # restore hydro inflow if there is a previous intercepted simulation.
  suppressWarnings({restoreHydroStorage(area = area, opts = opts,silent = T)})
  # restore Pump power if there is a previous intercepted simulation.
  suppressWarnings({restorePumpPower(area = area, opts = opts,silent = T)})

  suppressWarnings({restore_fictive_fatal_prod_demand(area = area, opts = opts,silent = T)})

  # MC years
  assertthat::assert_that(is.numeric(mcyears)==TRUE)

  if(length(mcyears)==1){
    play_years <- seq(1,mcyears)
  }else{
    play_years <- mcyears
  }

  antaresEditObject::setPlaylist(playlist = play_years,opts = opts)

  #assert the weekly output of the area:

  antaresEditObject::editArea(name = area,
                              filtering =
                                antaresEditObject::filteringOptions(filter_synthesis = c("hourly" , "weekly", "annual"),
                                                                    filter_year_by_year = c("hourly", "weekly", "annual"))
                              ,opts = opts)

  #generating the fictive area parameters

  fictive_area <- if (!is.null(fictive_area)) fictive_area else paste0("watervalue_", area)
  fictive_area = tolower(fictive_area)
  thermal_cluster <- if (!is.null(thermal_cluster)) thermal_cluster else "water_value_cluster"

  # Get max hydro power that can be generated in a week
  if (is.null(constraint_values)){
    constraint_values <- constraint_generator(area=area,nb_disc_stock=nb_disc_stock,
                                              pumping=pumping,
                                              efficiency = efficiency,
                                              opts=opts, mcyears=play_years)
  }
  if ("mcYear" %in% names(constraint_values)){
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$mcYear %in% play_years, .data$week %in% 1:52)
    assertthat::assert_that(opts$antaresVersion>=870,
                            msg = "Scenarization of rhs of binding constraints not available with the version of Antares. Update the study to 8.7.0 or don't scenarize control values.")
  } else {
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$week %in% 1:52)
  }
  nb_disc_stock <- dplyr::n_distinct(constraint_values$sim)

  # Get efficiency

  if (is.null(efficiency)){
    efficiency <- getPumpEfficiency(area = area)

  }

  #create the fictive areas

  opts <- setupWaterValuesSimulation(
    area = area,
    fictive_area_name = fictive_area,
    thermal_cluster = thermal_cluster,
    overwrite = overwrite,
    remove_areas=remove_areas,
    reset_hydro=reset_hydro,
    opts = opts,
    link_from = link_from,
    pumping=pumping,
    max_load=max(abs(constraint_values$u))*10
  )



  #generate the flow sens
  fictive_areas <- c(paste0(fictive_area,"_turb"))
  coeff <- generate_link_coeff(area,fictive_areas[1])

  if(pumping){
    fictive_areas <- c(fictive_areas,paste0(fictive_area,"_pump"))
    coeff_pump <- generate_link_coeff(area,fictive_areas[2])
    coeff <- c(coeff,coeff_pump)
  }

  opts <- antaresEditObject::createDistrict(
    name = "water values district",
    caption = "water values district",
    comments = "Used for calculate water values",
    apply_filter = "add-all",
    remove_area = fictive_areas,
    output = TRUE,
    overwrite = TRUE,
    opts = opts
  )

  # Start the simulations

  simulation_names <- vector(mode = "character", length = nb_disc_stock)

  # Implement binding constraint
  generate_constraints(coeff=coeff,name_constraint=binding_constraint,
                       efficiency=efficiency,opts=opts,area = area)

  for (i in 1:nb_disc_stock) {
    # Prepare simulation parameters
    name_sim <- dplyr::distinct(constraint_values,.data$sim)$sim[[i]]
    constraint_value <- dplyr::filter(constraint_values,.data$sim==name_sim)

    generate_rhs_bc(constraint_value=constraint_value,name_constraint=binding_constraint,opts=opts)

    sim_name <- paste0(file_name,"_",sprintf(simulation_name, format(
      name_sim, decimal.mark = ",")))
    message("#  ------------------------------------------------------------------------")
    message(paste0("Running simulation: ", i, " - ", sim_name))
    message("#  ------------------------------------------------------------------------")
    # run the simulation
    if(launch_simulations){
      assertthat::assert_that(stringr::str_detect(path_solver,"solver.exe$"),
                              msg = "Path solver is not the solver executable of Antares.")
      antaresEditObject::runSimulation(
        name = sim_name,
        mode = if (!expansion){"economy"}else{"expansion"},
        wait = wait,
        path_solver = path_solver,
        show_output_on_console = show_output_on_console,
        opts = opts
      )
    }
    simulation_names[i] <- sim_name

    if(launch_simulations){
      #Simulation Control
      sim_name <- utils::tail(getSimulationNames(pattern =sim_name , opts = opts),n=1)
      sim_check <- file.path(opts$studyPath,"output",sim_name)
      info <- antaresRead::readIniFile(file.path(sim_check, "info.antares-output"))$general

      if(!dir.exists(file.path(sim_check,"economy","mc-all"))){

        #remove the Binding Constraints

        disable_constraint(binding_constraint,opts,pumping,area = area)
        # remove the fictive area
        suppressWarnings({
          for (fictive_area in fictive_areas){
            antaresEditObject::removeArea(fictive_area,opts = opts)
          }
        })

        # restore hydrostorage
        restoreHydroStorage(area = area, opts = opts)
        restorePumpPower(area = area, opts = opts)
        restore_fictive_fatal_prod_demand(area = area, opts = opts)
        stop("Simulation Error. Please check simulation log.")
      }
      if(info$mode != "Economy"){
        message("This mode is not compatible with this version of Antares and AntaresRead. Use mode Economy instead.")
      }
    }
  }

  #remove the Binding Constraints

  disable_constraint(binding_constraint,opts,pumping,area = area)

  # remove the fictive area
  if(launch_simulations){
    suppressWarnings({
      for (fictive_area in fictive_areas){
        antaresEditObject::removeArea(fictive_area,opts = opts)
      }
    })
  }

  # restore hydrostorage
  restoreHydroStorage(area = area, opts = opts)
  restorePumpPower(area = area, opts = opts)
  restore_fictive_fatal_prod_demand(area = area, opts = opts)

  simulation_res <- list(
    simulation_names = simulation_names,
    simulation_values = constraint_values,
    area = area,
    mc_years = mcyears,
    pumping = pumping,
    eff = efficiency,
    expansion = expansion,
    fictive_areas = fictive_areas
  )

  if(!is.null(otp_dest)){

    main_path <- getwd()

    setwd(otp_dest)

    save(simulation_res,file=paste0(file_name,".RData"))

    setwd(main_path)
  }

  return(simulation_res)

}

#' Reset an Antares study. In case, there is a problem when executing \code{runWaterValuesSimulation},
#' run this function to restore the study.
#'
#' @param opts  List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param area The area concerned by the simulation
#' @param pumping Boolean. True to take into account the pumping.
#' @param fictive_area Name of the fictive area created
#' @param binding_constraint character
#'
#' @export
resetStudy <- function(opts, area, pumping,fictive_area = NULL,
                       binding_constraint="weekly_water_amount"){

  fictive_area <- if (!is.null(fictive_area)) fictive_area else paste0("watervalue_", area)

  disable_constraint(binding_constraint,opts,pumping,area = area)

  fictive_areas <- c(paste0(fictive_area,"_turb"))

  if(pumping){
    fictive_areas <- c(fictive_areas,paste0(fictive_area,"_pump"))
  }

  for (fictive_area in fictive_areas){
    if (fictive_area %in% opts$areaList){
      antaresEditObject::removeArea(fictive_area,opts = opts)
    }
  }

  # restore hydrostorage
  restoreHydroStorage(area = area, opts = opts)
  restorePumpPower(area = area, opts = opts)
  restore_fictive_fatal_prod_demand(area = area, opts = opts)
}

#' Run Antares simulations in order to compute water values for multiple areas
#'
#' Each simulation evaluates for each week and each scenario the cost of a set of controls for all areas in \code{list_areas}.
#'
#' @inheritParams runWaterValuesSimulation
#' @param constraint_values Constraint values for each area to use to run simulations, generated by the function \code{\link{constraint_generator}} with an additional column \code{"area"}.
#' @param list_areas Vector of areas concerned by simulations.
#' @param list_pumping Named vector of binary to tell if pumping is available in areas.
#' @param list_efficiency Named vector of pumping efficiency.
#'
#' @seealso \code{runWaterValuesSimulation()}
#' @returns
#' \item{simulation_names}{Vector of character. Names of simulations.}
#' \item{simulation_values}{A \code{dplyr::tibble()} generated by \code{constraint_generator()} describing controls for each simulation.}
#' \item{list_areas}{Parameter \code{list_areas}.}
#' \item{mc_years}{Parameter \code{mcyears}.}
#' \item{pumping}{Parameter \code{pumping}.}
#' \item{eff}{Parameter \code{efficiency}.}
#' \item{expansion}{Parameter \code{expansion}.}
#' \item{fictive_areas}{Parameter \code{fictive_areas}.}
#'
#' @export
runWaterValuesSimulationMultiStock <- function(list_areas,
                                               list_pumping,
                                               list_efficiency,
                                     simulation_name = "wv_sim_%s",
                                     mcyears = NULL,
                                     binding_constraint = "weekly_water_amount",
                                     path_solver=NULL,
                                     wait = TRUE,
                                     show_output_on_console = FALSE,
                                     overwrite = FALSE,
                                     opts = antaresRead::simOptions(),
                                     shiny=F,otp_dest=NULL,file_name=NULL,
                                     launch_simulations=T,
                                     reset_hydro=T,
                                     constraint_values=NULL,
                                     expansion=T){


  #check the study is well selected
  assertthat::assert_that(class(opts) == "simOptions")

  # check the name format

  if(!endsWith(simulation_name,"_%s")){
    simulation_name <- paste0(simulation_name,"_%s")
  }

  # MC years
  assertthat::assert_that(is.numeric(mcyears)==TRUE)

  if(length(mcyears)==1){
    play_years <- seq(1,mcyears)
  }else{
    play_years <- mcyears
  }

  antaresEditObject::setPlaylist(playlist = play_years,opts = opts)

  if ("mcYear" %in% names(constraint_values)){
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$mcYear %in% play_years, .data$week %in% 1:52)
  } else {
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$week %in% 1:52)
  }
  nb_disc_stock <- dplyr::n_distinct(constraint_values$sim)

  remove_area <- c()
  list_coeff <- list()

  for (j in 1:length(list_areas)){
    area <- list_areas[[j]]
    disable_constraint(paste0(binding_constraint,"_",area),opts,list_pumping[[j]],area = area)
    # restore hydro inflow if there is a previous intercepted simulation.
    restoreHydroStorage(area = area, opts = opts,silent = T)
    # restore Pump power if there is a previous intercepted simulation.
    restorePumpPower(area = area, opts = opts,silent = T)

    restore_fictive_fatal_prod_demand(area = area, opts = opts,silent = T)

    #assert the weekly output of the area:

    antaresEditObject::editArea(name = area,
                                filtering =
                                  antaresEditObject::filteringOptions(filter_synthesis = c("hourly" , "weekly", "annual"),
                                                                      filter_year_by_year = c("hourly", "weekly", "annual"))
                                ,opts = opts)

    #generating the fictive area parameters

    fictive_area <- paste0("watervalue_", area)
    thermal_cluster <- "water_value_cluster"

    #create the fictive areas

    opts <- setupWaterValuesSimulation(
      area = area,
      fictive_area_name = fictive_area,
      thermal_cluster = thermal_cluster,
      overwrite = overwrite,
      reset_hydro=reset_hydro,
      opts = opts,
      pumping=list_pumping[area],
      max_load=max(abs(constraint_values$u))*10
    )

    #generate the flow sens
    fictive_areas <- c(paste0(fictive_area,"_turb"))
    coeff <- generate_link_coeff(area,fictive_areas[1])

    if(list_pumping[area]){
      fictive_areas <- c(fictive_areas,paste0(fictive_area,"_pump"))
      coeff_pump <- generate_link_coeff(area,fictive_areas[2])
      coeff <- c(coeff,coeff_pump)
    }

    if (length(list_coeff)==0){
      list_coeff <- list(coeff)
    } else {
      list_coeff <- c(list_coeff,list(coeff))
    }

    remove_area <- c(remove_area,fictive_areas)

    # Implement binding constraint
    generate_constraints(coeff=coeff,name_constraint=paste0(binding_constraint,"_",area),
                         efficiency=list_efficiency[area],opts=opts,area = area)

    opts <- antaresEditObject::createDistrict(
      name = paste0("district_balance_",area),
      apply_filter = "add-all",
      remove_area = fictive_areas,
      output = TRUE,
      overwrite = TRUE,
      opts = opts
    )

  }

  opts <- antaresEditObject::createDistrict(
    name = "water values district",
    caption = "water values district",
    comments = "Used for calculate water values",
    apply_filter = "add-all",
    remove_area = remove_area,
    output = TRUE,
    overwrite = TRUE,
    opts = opts
  )

  # Start the simulations

  simulation_names <- vector(mode = "character", length = nb_disc_stock)

  for (i in 1:nb_disc_stock) {
    # Prepare simulation parameters
    name_sim <- dplyr::distinct(constraint_values,.data$sim)$sim[[i]]

    for (j in 1:length(list_areas)){
      constraint_value <- dplyr::filter(constraint_values,.data$sim==name_sim,
                                        .data$area==list_areas[[j]]) %>%
        dplyr::select(-c("area"))

      if (length(list_areas)==1){
        coeff <- list_coeff
      } else {
        coeff <- list_coeff[[j]]
      }
      generate_rhs_bc(constraint_value=constraint_value,
                      name_constraint=paste0(binding_constraint,"_",area),opts=opts)
    }


    sim_name <- paste0(file_name,"_",sprintf(simulation_name, format(
      stringr::str_extract(name_sim, "\\d+$"), decimal.mark = ",")))
    message("#  ------------------------------------------------------------------------")
    message(paste0("Running simulation: ", i, " - ", sim_name))
    message("#  ------------------------------------------------------------------------")
    # run the simulation
    if(launch_simulations){
      assertthat::assert_that(stringr::str_detect(path_solver,"solver.exe$"),
                              msg = "Path solver is not the solver executable of Antares.")
      antaresEditObject::runSimulation(
        name = sim_name,
        mode = if (!expansion){"economy"}else{"expansion"},
        wait = wait,
        path_solver = path_solver,
        show_output_on_console = show_output_on_console,
        opts = opts
      )
    }
    simulation_names[i] <- sim_name

    if(launch_simulations){
      #Simulation Control
      sim_name <- utils::tail(getSimulationNames(pattern =sim_name , opts = opts),n=1)
      sim_check <- file.path(opts$studyPath,"output",sim_name)
      info <- antaresRead::readIniFile(file.path(sim_check, "info.antares-output"))$general

      if(!dir.exists(file.path(sim_check,"economy","mc-all"))){
        #remove the Binding Constraints

        for (j in 1:length(list_areas)){
          area <- list_areas[[j]]
          disable_constraint(paste0(binding_constraint,"_",area),opts,list_pumping[[j]],area = area)
          # restore hydrostorage
          restoreHydroStorage(area = area, opts = opts)
          restorePumpPower(area = area, opts = opts)
          restore_fictive_fatal_prod_demand(area = area, opts = opts)
        }
        # remove the fictive area
        suppressWarnings({
          for (fictive_area in remove_area){
            antaresEditObject::removeArea(fictive_area,opts = opts)
          }
        })

        stop("Simulation Error. Please check simulation log.")
      }
      if(info$mode != "Economy"){
        message("This mode is not compatible with this version of Antares and AntaresRead. Use mode Economy instead.")
      }
    }

  }

  for (j in 1:length(list_areas)){
    area <- list_areas[[j]]
    disable_constraint(paste0(binding_constraint,"_",area),opts,list_pumping[[j]],area = area)
    # restore hydrostorage
    restoreHydroStorage(area = area, opts = opts)
    restorePumpPower(area = area, opts = opts)
    restore_fictive_fatal_prod_demand(area = area, opts = opts)
  }

  # remove the fictive area
  if(launch_simulations){
    suppressWarnings({
      for (fictive_area in remove_area){
        antaresEditObject::removeArea(fictive_area,opts = opts)
      }
    })
  }

  simulation_res <- list(
    simulation_names = simulation_names,
    simulation_values = constraint_values,
    list_areas = list_areas,
    mc_years = mcyears,
    list_pumping = list_pumping,
    list_eff = list_efficiency,
    expansion = expansion,
    fictive_areas = remove_area
  )

  if(!is.null(otp_dest)){

    main_path <- getwd()

    setwd(otp_dest)

    save(simulation_res,file=paste0(file_name,".RData"))

    setwd(main_path)
  }

  return(simulation_res)

}



#' Run a simulation for calculating water values for a specific area
#'
#' @param area The area concerned by the simulation.
#' @param simulation_name The name of the simulation, \code{s} is a placeholder for the constraint value defined by \code{nb_disc_stock}.
#' @param nb_disc_stock Number of simulation to launch, a vector of energy constraint
#'  will be created from maximum pumping power to the hydro storage maximum and of length this parameter.
#' @param mcyears Number of Monte Carlo years to simulate or a vector of years indexes to launch.
#' @param binding_constraint Name of the binding constraint.
#  constraint_values Vector of energy constraints on the link between the area and the fictive area.
#' @param fictive_area Name of the fictive area to create, argument passed to \code{\link{setupWaterValuesSimulation}}.
#'
#' @param thermal_cluster Name of the thermal cluster to create, argument passed to \code{\link{setupWaterValuesSimulation}}.
#' @param path_solver Character containing the Antares Solver path, argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param show_output_on_console Argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param overwrite If area or cluster already exists, should they be overwritten?
#' @param link_from area that will be linked to the created fictive area. If it's
#' \code{NULL} it will takes the area concerned by the simulation.
#' @param otp_dest the path in which the script save Rdata file.
#' @param file_name the Rdata file name.
#' @param remove_areas 	Character vector of area(s) to remove from the created district.
#' @param pumping Boolean. True to take into account the pumping.
#' @param efficiency in [0,1]. efficient ratio of pumping.
#' @param launch_simulations Boolean. True to to run the simulations.
#' @param opts
#'   List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param area area
#' @param simulation_name character
#' @param nb_disc_stock integer
#' @param mcyears list of Monte Carlo years
#' @param constraint_values constraint values to use to run simulations, generated by the function \code{\link{constraint_generator}}
#' @param binding_constraint character
#' @param expansion Binary. True if mode expansion was used to run simulations
#'
#' @note This function have side effects on the Antares study used, a fictive area is created and a new district as well.
#'
#' @export
#'

runWaterValuesSimulation <- function(area,
                                     simulation_name = "wv_sim_%s",
                                     nb_disc_stock = 10,
                                     mcyears = NULL,
                                     binding_constraint = "weekly_water_amount",
                                     fictive_area = NULL,
                                     thermal_cluster = NULL,
                                     path_solver=NULL,
                                     show_output_on_console = FALSE,
                                     overwrite = FALSE,
                                     link_from=NULL,
                                     remove_areas=NULL,
                                     opts = antaresRead::simOptions(),
                                     otp_dest=NULL,
                                     file_name=NULL,
                                     pumping=F,
                                     efficiency=NULL,
                                     launch_simulations=T,
                                     constraint_values=NULL,
                                     expansion=T){

  area = tolower(area)
  antaresEditObject:::check_area_name(area = area, opts = opts)
  assertthat::assert_that(area %in% names(opts$energyCosts$unserved),
                          msg=paste0("Unserved cost is null in ",area,
                                     ", unserved energy will be exported to this area in simulations launched by the package."))

  backup = getBackupData(area,mcyears,opts)

  binding_constraint = tolower(binding_constraint)


  #check the study is well selected
  assertthat::assert_that(class(opts) == "simOptions")
  assertthat::assert_that(!antaresRead:::is_api_study(opts)|!expansion)
  # check the name format

  simulation_name <- tolower(simulation_name)
  if(!endsWith(simulation_name,"_%s")){
    simulation_name <- paste0(simulation_name,"_%s")
  }

  file_name = tolower(file_name)
  if (!stringr::str_detect(file_name,area)){
    file_name <- paste0(area,"_",file_name)
  }

  #assert the weekly output of the area:
  area_filtering = antaresRead::readIni(file.path("input","areas",area,"optimization.ini"),
                                        opts=opts)
  assertthat::assert_that(stringr::str_detect(area_filtering$filtering$`filter-year-by-year`,"hourly"),
                          msg = paste0(area," must have year by year hourly output."))

  #generating the fictive area parameters

  fictive_area <- if (!is.null(fictive_area)) fictive_area else paste0("watervalue_", area)
  fictive_area = tolower(fictive_area)
  thermal_cluster <- if (!is.null(thermal_cluster)) thermal_cluster else "water_value_cluster"

  # Get max hydro power that can be generated in a week
  if (is.null(constraint_values)){
    constraint_values <- constraint_generator(area=area,nb_disc_stock=nb_disc_stock,
                                              pumping=pumping,
                                              pumping_efficiency = efficiency,
                                              opts=opts, mcyears=mcyears)
  }
  if ("mcYear" %in% names(constraint_values)){
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$mcYear %in% mcyears, .data$week %in% 1:52)
    assertthat::assert_that(opts$antaresVersion>=870,
                            msg = "Scenarization of rhs of binding constraints not available with the version of Antares. Update the study to 8.7.0 or don't scenarize control values.")
  } else {
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$week %in% 1:52)
  }
  nb_disc_stock <- dplyr::n_distinct(constraint_values$sim)

  # Get efficiency

  if (is.null(efficiency)){
    efficiency <- getPumpEfficiency(area = area)

  }

  simulation_res <- list()

  #create the fictive areas
  tryCatch({
    opts <- setupWaterValuesSimulation(
      area = area,
      fictive_area_name = fictive_area,
      thermal_cluster = thermal_cluster,
      overwrite = overwrite,
      opts = opts,
      pumping=pumping,
      backup = backup
    )

    # MC years
    antaresEditObject::setPlaylist(playlist = mcyears,opts = opts)

    # Activate output year by year
    antaresEditObject::updateGeneralSettings(year.by.year = TRUE, opts = opts)

    # Adjust thematic trimming
    settings_ini <- antaresRead::readIni(file.path("settings", "generaldata"),
                                         opts=opts)
    if (settings_ini$general$`thematic-trimming`){
      for (p in list("OV. COST","MRG. PRICE","BALANCE")){
        if (p %in% settings_ini$`variables selection`){
          idx <- which(settings_ini$`variables selection`== p)
          settings_ini$`variables selection`[[idx]] <- NULL
        }
        settings_ini$`variables selection` <- append(settings_ini$`variables selection`,
                                                     list(`select_var +`=p))
      }
      antaresEditObject::writeIni(settings_ini,
                                  file.path("settings", "generaldata"),
                                  overwrite=T,
                                  opts=opts)
    }


    #generate the flow sens
    fictive_areas <- c(paste0(fictive_area,"_turb"))
    coeff <- generate_link_coeff(area,fictive_areas[1])

    if(pumping){
      fictive_areas <- c(fictive_areas,paste0(fictive_area,"_pump"))
      coeff_pump <- generate_link_coeff(area,fictive_areas[2])
      coeff <- c(coeff,coeff_pump)
    }

    if (!"water values district" %in% opts$districtsDef$district){
      opts <- antaresEditObject::createDistrict(
        name = "water values district",
        caption = "water values district",
        comments = "Used for calculate water values",
        apply_filter = "add-all",
        remove_area = fictive_areas,
        output = TRUE,
        overwrite = TRUE,
        opts = opts
      )
    }

    # Start the simulations

    simulation_names <- vector(mode = "character", length = nb_disc_stock)

    # Implement binding constraint
    generate_constraints(coeff=coeff,name_constraint=binding_constraint,
                         efficiency=efficiency,opts=opts,area = area)

    for (i in 1:nb_disc_stock) {
      # Prepare simulation parameters
      name_sim <- dplyr::distinct(constraint_values,.data$sim)$sim[[i]]
      constraint_value <- dplyr::filter(constraint_values,.data$sim==name_sim)

      generate_rhs_bc(constraint_value=constraint_value,name_constraint=binding_constraint,opts=opts)

      sim_name <- paste0(file_name,"_",sprintf(simulation_name, format(
        name_sim, decimal.mark = ",")))
      message("#  ------------------------------------------------------------------------")
      message(paste0("Running simulation: ", i, " - ", sim_name))
      message("#  ------------------------------------------------------------------------")
      # run the simulation
      if(launch_simulations){
        assertthat::assert_that(stringr::str_detect(path_solver,"solver.exe$"),
                                msg = "Path solver is not the solver executable of Antares.")
        status = antaresEditObject::runSimulation(
          name = sim_name,
          mode = if (!expansion){"economy"}else{"expansion"},
          path_solver = path_solver,
          show_output_on_console = show_output_on_console,
          opts = opts
        )
        if (antaresRead:::is_api_study(opts)){
          assertthat::assert_that(status$status == "success")
          simu <- antaresRead::setSimulationPathAPI(host = opts$host,
                                                    study_id = opts$study_id,
                                                    token = opts$token,
                                                    simulation = -1)
        } else {
          assertthat::assert_that(status == 0)
          simu <- antaresRead::setSimulationPath(opts$studyPath,
                                                 simulation = -1)
          info <- antaresRead::readIni(file.path(stringr::str_remove(simu$simPath,".*(?=output/)"),
                                                 "info.antares-output"),
                                       opts=opts,
                                       default_ext = "antares-output")$general
          if(info$mode != "Economy"){
            message("This mode is not compatible with this version of Antares and AntaresRead. Use mode Economy instead.")
          }
        }
      }
      simulation_names[i] <- sim_name
    }

    simulation_res <- list(
      simulation_names = simulation_names,
      simulation_values = constraint_values,
      area = area,
      mc_years = mcyears,
      pumping = pumping,
      eff = efficiency,
      expansion = expansion,
      fictive_areas = fictive_areas
    )

    if(!is.null(otp_dest)&!antaresRead:::is_api_study(opts)){

      main_path <- getwd()

      setwd(otp_dest)

      save(simulation_res,file=paste0(file_name,".RData"))

      setwd(main_path)
    }

  },
  finally = resetStudy(opts,area,pumping,fictive_area,binding_constraint,backup))


  return(simulation_res)
}

#' Reset an Antares study. In case, there is a problem when executing \code{runWaterValuesSimulation},
#' run this function to restore the study.
#'
#' @param opts  List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param area The area concerned by the simulation
#' @param pumping Boolean. True to take into account the pumping.
#' @param fictive_area Name of the fictive area created
#' @param binding_constraint character
#' @param backup List with hydro_storage, load and misc_gen backups for area
#' generated by the function \code{getBackupData}
#'
#' @export
resetStudy <- function(opts, area, pumping,fictive_area = NULL,
                       binding_constraint="weekly_water_amount",
                       backup){
  message("Please, don't interupt ! Your study is being reset.")
  fictive_area <- if (!is.null(fictive_area)) fictive_area else paste0("watervalue_", area)

  disable_constraint(binding_constraint,opts,pumping,area = area)

  fictive_areas <- c(paste0(fictive_area,"_turb"))

  if(pumping){
    fictive_areas <- c(fictive_areas,paste0(fictive_area,"_pump"))
  }

  for (fictive_area in fictive_areas){
    if (fictive_area %in% opts$areaList){
      suppressWarnings(antaresEditObject::removeArea(fictive_area,opts = opts))
    }
  }

  restoreHydroStorage(area = area, opts = opts, data=backup$hydro_storage)
  restore_fictive_fatal_prod_demand(area = area, opts = opts, load = backup$load,
                                    misc_gen = backup$misc_gen)
}

#' Run a simulation for calculating water values for a specific area
#'
#' @param simulation_name The name of the simulation, \code{s} is a placeholder for the constraint value defined by \code{nb_disc_stock}.
#' @param nb_mcyears Number of Monte Carlo years to simulate or a vector of years indexes to launch.
#' @param binding_constraint Name of the binding constraint.
#' @param path_solver Character containing the Antares Solver path, argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param show_output_on_console Argument passed to \code{\link[antaresEditObject]{runSimulation}}.
#' @param overwrite If area or cluster already exists, should they be overwritten?
#' @param otp_dest the path in which the script save Rdata file.
#' @param file_name the Rdata file name.
#' @param launch_simulations Boolean. True to to run the simulations.
#' @param opts
#'   List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param simulation_name character
#' @param constraint_values constraint values to use to run simulations, generated by the function \code{\link{constraint_generator}}
#' @param binding_constraint character
#' @param list_areas List of areas concerned by the simulation.
#' @param list_pumping List of bools to tell if pumping is available in areas
#' @param list_efficiency List of pumping efficiency
#' @param expansion Binary. True if mode expansion was used to run simulations
#'
#' @note This function have side effects on the Antares study used, a fictive area is created and a new district as well.
#'
#' @export
#'

runWaterValuesSimulationMultiStock <- function(list_areas,
                                               list_pumping,
                                               list_efficiency,
                                     simulation_name = "wv_sim_%s",
                                     nb_mcyears = NULL,
                                     binding_constraint = "weekly_water_amount",
                                     path_solver=NULL,
                                     show_output_on_console = FALSE,
                                     overwrite = FALSE,
                                     opts = antaresRead::simOptions(),
                                     otp_dest=NULL,
                                     file_name=NULL,
                                     launch_simulations=T,
                                     constraint_values=NULL,
                                     expansion=T){


  #check the study is well selected
  assertthat::assert_that(class(opts) == "simOptions")

  # check the name format

  if(!endsWith(simulation_name,"_%s")){
    simulation_name <- paste0(simulation_name,"_%s")
  }

  # MC years
  assertthat::assert_that(is.numeric(nb_mcyears)==TRUE)

  if(length(nb_mcyears)==1){
    mcyears <- seq(1,nb_mcyears)
  }else{
    mcyears <- nb_mcyears
  }

  antaresEditObject::setPlaylist(playlist = mcyears,opts = opts)

  if ("mcYear" %in% names(constraint_values)){
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$mcYear %in% mcyears, .data$week %in% 1:52)
  } else {
    constraint_values <- constraint_values %>%
      dplyr::filter(.data$week %in% 1:52)
  }
  nb_disc_stock <- dplyr::n_distinct(constraint_values$sim)

  remove_area <- c()
  list_coeff <- list()

  for (j in 1:length(list_areas)){
    area <- list_areas[[j]]
    disable_constraint(paste0(binding_constraint,"_",area),opts,list_pumping[[j]],area = area)
    # restore hydro inflow if there is a previous intercepted simulation.
    restoreHydroStorage(area = area, opts = opts)

    restore_fictive_fatal_prod_demand(area = area, opts = opts)

    #assert the weekly output of the area:

    antaresEditObject::editArea(name = area,
                                filtering =
                                  antaresEditObject::filteringOptions(filter_synthesis = c("hourly" , "weekly", "annual"),
                                                                      filter_year_by_year = c("hourly", "weekly", "annual"))
                                ,opts = opts)

    #generating the fictive area parameters

    fictive_area <- paste0("watervalue_", area)
    thermal_cluster <- "water_value_cluster"

    #create the fictive areas

    opts <- setupWaterValuesSimulation(
      area = area,
      fictive_area_name = fictive_area,
      thermal_cluster = thermal_cluster,
      overwrite = overwrite,
      opts = opts,
      pumping=list_pumping[area]
    )

    #generate the flow sens
    fictive_areas <- c(paste0(fictive_area,"_turb"))
    coeff <- generate_link_coeff(area,fictive_areas[1])

    if(list_pumping[area]){
      fictive_areas <- c(fictive_areas,paste0(fictive_area,"_pump"))
      coeff_pump <- generate_link_coeff(area,fictive_areas[2])
      coeff <- c(coeff,coeff_pump)
    }

    if (length(list_coeff)==0){
      list_coeff <- list(coeff)
    } else {
      list_coeff <- c(list_coeff,list(coeff))
    }

    remove_area <- c(remove_area,fictive_areas)

    # Implement binding constraint
    generate_constraints(coeff=coeff,name_constraint=paste0(binding_constraint,"_",area),
                         efficiency=list_efficiency[area],opts=opts,area = area)

    opts <- antaresEditObject::createDistrict(
      name = paste0("district_balance_",area),
      apply_filter = "add-all",
      remove_area = fictive_areas,
      output = TRUE,
      overwrite = TRUE,
      opts = opts
    )

  }

  opts <- antaresEditObject::createDistrict(
    name = "water values district",
    caption = "water values district",
    comments = "Used for calculate water values",
    apply_filter = "add-all",
    remove_area = remove_area,
    output = TRUE,
    overwrite = TRUE,
    opts = opts
  )

  # Start the simulations

  simulation_names <- vector(mode = "character", length = nb_disc_stock)

  for (i in 1:nb_disc_stock) {
    # Prepare simulation parameters
    name_sim <- dplyr::distinct(constraint_values,.data$sim)$sim[[i]]

    for (j in 1:length(list_areas)){
      constraint_value <- dplyr::filter(constraint_values,.data$sim==name_sim,
                                        .data$area==list_areas[[j]]) %>%
        dplyr::select(-c("area"))

      if (length(list_areas)==1){
        coeff <- list_coeff
      } else {
        coeff <- list_coeff[[j]]
      }
      generate_rhs_bc(constraint_value=constraint_value,
                      name_constraint=paste0(binding_constraint,"_",area),opts=opts)
    }


    sim_name <- paste0(file_name,"_",sprintf(simulation_name, format(
      stringr::str_extract(name_sim, "\\d+$"), decimal.mark = ",")))
    message("#  ------------------------------------------------------------------------")
    message(paste0("Running simulation: ", i, " - ", sim_name))
    message("#  ------------------------------------------------------------------------")
    # run the simulation
    if(launch_simulations){
      assertthat::assert_that(stringr::str_detect(path_solver,"solver.exe$"),
                              msg = "Path solver is not the solver executable of Antares.")
      status = antaresEditObject::runSimulation(
        name = sim_name,
        mode = if (!expansion){"economy"}else{"expansion"},
        path_solver = path_solver,
        show_output_on_console = show_output_on_console,
        opts = opts
      )
    }
    simulation_names[i] <- sim_name

    if(launch_simulations){
      #Simulation Control
      simu <- antaresRead::setSimulationPath(opts$studyPath,
                                             simulation = -1)
      info <- antaresRead::readIni(file.path("output",
                                             simu$simOutputName,
                                             "info.antares-output"),
                                   opts=opts,
                                   default_ext = "antares-output")$general
      if(status != 0){
        #remove the Binding Constraints

        for (j in 1:length(list_areas)){
          area <- list_areas[[j]]
          disable_constraint(paste0(binding_constraint,"_",area),opts,list_pumping[[j]],area = area)
          # restore hydrostorage
          restoreHydroStorage(area = area, opts = opts)
          restore_fictive_fatal_prod_demand(area = area, opts = opts)
        }
        # remove the fictive area
        suppressWarnings({
          for (fictive_area in remove_area){
            antaresEditObject::removeArea(fictive_area,opts = opts)
          }
        })

        stop("Simulation Error. Please check simulation log.")
      }
      if(info$mode != "Economy"){
        message("This mode is not compatible with this version of Antares and AntaresRead. Use mode Economy instead.")
      }
    }

  }

  for (j in 1:length(list_areas)){
    area <- list_areas[[j]]
    disable_constraint(paste0(binding_constraint,"_",area),opts,list_pumping[[j]],area = area)
    # restore hydrostorage
    restoreHydroStorage(area = area, opts = opts)
    restore_fictive_fatal_prod_demand(area = area, opts = opts)
  }

  # remove the fictive area
  if(launch_simulations){
    suppressWarnings({
      for (fictive_area in remove_area){
        antaresEditObject::removeArea(fictive_area,opts = opts)
      }
    })
  }

  simulation_res <- list(
    simulation_names = simulation_names,
    simulation_values = constraint_values,
    list_areas = list_areas,
    mc_years = nb_mcyears,
    list_pumping = list_pumping,
    list_eff = list_efficiency,
    expansion = expansion,
    fictive_areas = remove_area
  )

  if(!is.null(otp_dest)){

    main_path <- getwd()

    setwd(otp_dest)

    save(simulation_res,file=paste0(file_name,".RData"))

    setwd(main_path)
  }

  return(simulation_res)

}

#' Generate backup data for area
#'
#' @param area Character
#' @param mcyears Monte Carlo years to simulate or a vector of years indexes to launch.
#' @param opts
#' List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#'
#' @return List with hydro_storage, load and misc_gen backups for area
#' @export
getBackupData <- function(area,
                          mcyears,
                          opts){
  backup <- list()
  hydro_storage <- antaresRead:::fread_antares(file = file.path(opts$inputPath, "hydro", "series", area, "mod.txt"),
                                               opts = opts)
  if (nrow(hydro_storage)==0){
    message("Hydro storage is empty")
    hydro_storage = matrix(rep(0,365),ncol=1)
  }
  backup$hydro_storage = hydro_storage

  load <- antaresRead:::fread_antares(file = file.path(opts$inputPath,"load", "series", paste0("load_",area,".txt")),
                                      opts=opts)
  if (nrow(load)==0){
    message("Load is empty")
    load = matrix(rep(0,8760),ncol=1)
  }
  backup$load = load

  misc_gen <- antaresRead:::fread_antares(file = file.path(opts$inputPath, "misc-gen", paste0("miscgen-",area,".txt")),
                                          opts=opts)
  if (nrow(misc_gen)==0){
    message("Misc gen is empty")
    misc_gen = matrix(rep(0,8*8760),ncol=8)
  }
  backup$misc_gen = misc_gen
  return(backup)
}

#' Setup a simulation before running it for calculating Water Values,
#' used in \code{runWaterValuesSimulation}
#'
#' @param area The area concerned by the simulation.
#' @param overwrite If area or cluster already exists, overwrite them ?
#' @param pumping Boolean. True to take into account the pumping.
#' @param efficiency Double. Pumping efficiency
#' @param opts
#'   List of simulation parameters returned by the function
#'   \code{antaresRead::setSimulationPath}
#' @param backup List with hydro_storage, load and misc_gen backups for area
#' generated by the function \code{getBackupData}
#' @return The result of antaresRead::simOptions
#' @keywords internal
setupWaterValuesSimulation <- function(area,
                                       overwrite = FALSE,
                                       opts,
                                       pumping=F,
                                       efficiency,
                                       backup) {

 assertthat::assert_that(area %in% names(opts$energyCosts$unserved),
                        msg=paste0("Unserved cost is null in ",area,
                                   ", unserved energy will be exported to this area in simulations launched by the package."))

  #assert the weekly output of the area:
  area_filtering = antaresRead::readIni(file.path("input","areas",area,"optimization.ini"),
                                        opts=opts)
  assertthat::assert_that(stringr::str_detect(area_filtering$filtering$`filter-year-by-year`,"hourly"),
                          msg = paste0(area," must have year by year hourly output."))

  suppressWarnings({mingen = antaresRead::readInputTS(mingen = area,opts=opts)})
  if (nrow(mingen)>0){
    assertthat::assert_that(max(dplyr::pull(mingen,"mingen"))==0,
                            msg = paste0("The module is not yet usable with min gen. Please set min gen to zero for area '",area,"'."))
  }

  fictive_area_name <- paste0("watervalue_", area)
  thermal_cluster <- "water_value_cluster"

  changeHydroManagement(opts=opts,watervalues = F, heuristic = T, area=area)

  add_fictive_fatal_prod_demand(area = area, opts = opts, load = backup$load,
                                misc_gen = backup$misc_gen)

  resetHydroStorage(area = area, opts = opts)

  # Get hydro max power
  hydro_storage_max <- get_max_hydro(area = area, opts=opts, timeStep = "hourly")

  # Prepare thermal Cluster parameters
  time_series = c(hydro_storage_max$turb, rep(0,24))
  nominalcapacity_turb <- max(hydro_storage_max$turb)
  nominalcapacity_pump <- max(hydro_storage_max$pump)

  fictive_areas <- c(paste0(fictive_area_name,"_turb"))
  if(pumping){
    fictive_areas <- c(fictive_areas,paste0(fictive_area_name,"_pump"))
  }

  assertthat::assert_that(opts$antaresVersion>860|max(abs(hydro_storage_max$pump-round(hydro_storage_max$pump)))==0,
                          msg = "This version of Antares can't take into account non integer pumping power.")

  for(fictive_area in fictive_areas){

    # Create fictive areas
    opts <- antaresEditObject::createArea(name = fictive_area,
                                            overwrite = overwrite,
                                            opts = opts)

    # Create thermal cluster
    if(grepl("_turb$", fictive_area)){
      opts <- antaresEditObject::createCluster(
          area = fictive_area,
          cluster_name = thermal_cluster,
          group = "other",
          unitcount = "1",
          time_series = time_series,
          nominalcapacity = nominalcapacity_turb,
          overwrite = overwrite,
          opts = opts
        )
    }

    if(grepl("_pump$", fictive_area)){
      antaresEditObject::writeInputTS(fictive_area, type = "load",
                                      data = c(hydro_storage_max$pump, rep(0,24)),
                                      opts = opts)
    }

    # Create link
    if(grepl("_turb$", fictive_area)|grepl("_pump$", fictive_area)){
     opts <- antaresEditObject::createLink(
          from = area,
          to = fictive_area,
          propertiesLink = antaresEditObject::propertiesLinkOptions(transmission_capacities = "infinite"), #
          dataLink = NULL,
          overwrite = overwrite,
          opts = opts
        )
    }

  }#end fictive areas loop

  if (!paste0("district_balance_",area) %in% opts$districtsDef$district){
    opts <- antaresEditObject::createDistrict(
      name = paste0("district_balance_",area),
      apply_filter = "add-all",
      remove_area = fictive_areas,
      output = TRUE,
      overwrite = TRUE,
      opts = opts
    )
  }

  generate_constraints(pumping=pumping,efficiency=efficiency,
                       opts=opts,area = area)

  return(opts)
}

setWaterValuesDistrict <- function(opts){
  remove_area <- antaresRead::getAreas("watervalue_",opts=opts)
  if (!"water values district" %in% opts$districtsDef$district){
    opts <- antaresEditObject::createDistrict(
      name = "water values district",
      caption = "water values district",
      comments = "Used for calculate water values",
      apply_filter = "add-all",
      remove_area = remove_area,
      output = TRUE,
      overwrite = TRUE,
      opts = opts
    )
  } else {
    message("Water values district already exists, this could be a problem. If so, try to remove it manually.")
  }

  return(opts)
}

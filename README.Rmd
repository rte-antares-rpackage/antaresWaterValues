---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

![](man/figures/antares_simulator.png){width="250"}

# antaresWaterValues

<!-- badges: start -->

<!-- badges: end -->

This package calculate water values for long term storages in Antares studies. It uses Antares simulations and dynamic programming.

More theoretical details are given in : `vignette("computation_watervalues")`.

## Installation

You can install the development version of antaresWaterValues from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("rte-antares-rpackage/antaresWaterValues")
```

To load the package use :

```{r}
library(antaresWaterValues)
```

Now we are ready to use our package.

## Using the Shiny app

```{r eval=FALSE}
study_path <- "your/path/to/the/antares/study"
shiny_water_values(antaresRead::setSimulationPath(study_path,"input"))
```

![](man/figures/calculate_water_values.gif)

## Without the Shiny app

Begin by defining some parameters about your study.

```{r eval=FALSE}
area <- "name_of_area"
pumping <- T #T if pumping possible
mcyears <- 1:10 # Monte Carlo years you want to use

opts <- antaresRead::setSimulationPath("your/path/to/the/antares/study","input")
pump_eff <- getPumpEfficiency(area,opts=opts)
```

Then, you have to run simulations.

```{r eval=FALSE}
simulation_res <- runWaterValuesSimulation(
    area=area,
    nb_disc_stock = 5, #number of simulations
    nb_mcyears = mcyears,
    path_solver = "your/path/to/antares/bin/antares-8.6-solver.exe",
    fictive_area = paste0("watervalue_",area),
    thermal_cluster = "watervaluecluster",
    overwrite = TRUE,
    link_from=area,
    opts = opts,
    otp_dest=paste0(study_path,"/user"),
    file_name="water_values", #name of the saving file
    pumping=pumping,
    efficiency=pump_eff,
    launch_simulations=T,
    reset_hydro=T
  )
```

It's now possible to calculate water values.

```{r eval=FALSE}
results <- Grid_Matrix(
  area=area,
  simulation_names=simulation_res$simulation_names,
  simulation_values=simulation_res$simulation_values,
  nb_cycle = 2L,
  mcyears = mcyears,
  week_53 = 0,#initial Bellman values
  states_step_ratio = 1/20, # discretization of states
  method= c("mean-grid","grid-mean","quantile")[1],
  q_ratio=0.5,# for quantile method
  opts = opts,
  pumping=pumping,
  efficiency=pump_eff,
  correct_concavity = FALSE,#correct concavity of Bellman values
  correct_monotony_gain = FALSE,#correct monotony of rewards
  penalty_low = 3,#penalty for bottom rule curve
  penalty_high = 0,#penalty for top rule curve
  method_old_gain = T,# T if you want a simple linear interpolation of rewards,
                      # F if you want to use marginal price to interpolate
  hours_reward_calculation = c(seq.int(0,168,10),168),# used for marginal prices interpolation
  controls_reward_calculation = constraint_generator(area=area,
                                                     nb_disc_stock = 20,
                                                     pumping = pumping,
                                                     pumping_efficiency = pump_eff,
                                                     opts=opts,
                                                     mcyears=mcyears),# used for marginal prices interpolation
force_final_level = F, # T if you want to constrain final level with penalties (see Grid_Matrix documentation for more information)
final_level = get_initial_level(area=area,opts=opts), # wanted final level (between 0 and 100%)
penalty_final_level_low = 4,
penalty_final_level_high = 1
)
aggregated_results <- results$aggregated_results
```

Water values are written to Antares thanks to the following instructions

```{r eval=FALSE}
reshaped_values <- aggregated_results[aggregated_results$weeks!=53,] %>%
  to_Antares_Format()
antaresEditObject::writeWaterValues(
  area = area,
  data = reshaped_values
)
```

### Plot results

```{r, include=FALSE}
aggregated_results <- example_aggregated_results
reward <- example_reward
```

```{r watervalues}
waterValuesViz(Data=aggregated_results,filter_penalties = F)
```

```{r eval=FALSE}
plot_Bellman(value_nodes_dt = aggregated_results, 
             week_number = c(1,3))
```

You can also plot reward functions

```{r eval=FALSE}
reward <- get_Reward(
  simulation_names = simulation_res$simulation_names,
  simulation_values = simulation_res$simulation_values,
  opts=opts,
  area = area,
  mcyears = mcyears,
  pump_eff = pump_eff,
  method_old = T,# T if you want a simple linear interpolation of rewards,
                 # F if you want to use marginal price to interpolate
  possible_controls = constraint_generator(area=area,
                                           nb_disc_stock = 20,
                                           pumping = pumping,
                                           pumping_efficiency = pump_eff,
                                           opts=opts)# used for marginal prices interpolation
)
reward <- reward$reward
```

```{r reward}
plot_1 <- plot_reward(reward_base = reward,
                      week_id = c(1,3))
plot_2 <- plot_reward_mc(reward_base = reward,
                         week_id = c(1,3),
                         Mc_year = c(1,2))
plot_3 <- plot_reward_variation(reward_base = reward,
                                week_id = c(1,3))
plot_4 <- plot_reward_variation_mc(reward_base = reward,
                                   week_id = c(1,3),
                                   Mc_year = c(1,2))
```

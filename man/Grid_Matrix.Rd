% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Grid_Matrix.R
\name{Grid_Matrix}
\alias{Grid_Matrix}
\title{Calculate grid layer matrix of Bellman values and water values}
\usage{
Grid_Matrix(
  area,
  simulation_names,
  expansion,
  reward_db = NULL,
  inflow = NULL,
  simulation_values = NULL,
  nb_cycle = 1L,
  district_name = "water values district",
  mcyears = NULL,
  week_53 = 0,
  states_step_ratio = 0.01,
  reservoir_capacity = NULL,
  na_rm = FALSE,
  method,
  only_input = FALSE,
  q_ratio = 0.5,
  test_week = NULL,
  opts = antaresRead::simOptions(),
  shiny = F,
  until_convergence = F,
  convergence_rate = 0.9,
  convergence_criteria = 1,
  cycle_limit = 10,
  pumping = F,
  efficiency = 1,
  stop_rate = 0,
  debug_week = 54,
  correct_concavity = FALSE,
  correct_monotony_gain = FALSE,
  penalty_low = 3000,
  penalty_high = 3000,
  method_old_gain = F,
  controls_reward_calculation = NULL,
  max_hydro_hourly = NULL,
  max_hydro_weekly = NULL,
  force_final_level = F,
  final_level = NULL,
  penalty_final_level_low = NULL,
  penalty_final_level_high = NULL,
  ...
)
}
\arguments{
\item{area}{An 'antares' area.}

\item{simulation_names}{Names of simulations to retrieve.}

\item{expansion}{Binary. True if mode expansion was used to run simulations}

\item{reward_db}{a table contains the reward values generated by the function \code{get_Reward}
If it's NULL it auto calculated.}

\item{inflow}{a table contains the hydro storage generated by the function \code{readAntares}
with th option \code{hydrostorage = TRUE}. If it's NULL it auto calculated.}

\item{simulation_values}{Values for the simulation.}

\item{nb_cycle}{Number of times to run the algorithm.}

\item{district_name}{Name of the district used to store output.}

\item{mcyears}{MC years to consider, by default all of them.}

\item{week_53}{Water values for week 53, by default 0.}

\item{states_step_ratio}{Discretization ratio to generate steps levels
between the reservoir capacity and zero . Defaults to 0.05}

\item{reservoir_capacity}{Reservoir capacity for the given area in MWh,
if \code{NULL} (the default), value in Antares is used if available else
a prompt ask the user the value to be used.}

\item{na_rm}{Remove NAs}

\item{method}{Perform mean of grids algorithm or grid of means algorithm or
grid of quantile algorithm.}

\item{only_input}{if TRUE skip bellman values calculation and return the input}

\item{q_ratio}{from 0 to 1. the probability used in quantile method
to determine a bellman value which q_ratio all bellman values are equal or
less to it. (quantile(q_ratio))}

\item{test_week}{the week number u want to see it's calculation information
in the console}

\item{opts}{List of simulation parameters returned by the function
\code{antaresRead::setSimulationPath}}

\item{shiny}{Boolean. True to run the script in shiny mode.}

\item{until_convergence}{Boolean. TRUE to repeat cycle until convergence or
attending the limit.}

\item{convergence_rate}{from 0 to 1. Define the convergence level from which
we suppose that no need to continue another cycle..}

\item{convergence_criteria}{the value define convergence. if the difference
between two water values is less then this value those values are converged.}

\item{cycle_limit}{Define cycles limit when you are in the until_convergence mod.}

\item{pumping}{Boolean. True to take into account the pumping.}

\item{efficiency}{in [0,1]. efficient ratio of pumping.}

\item{stop_rate}{the percent from which the calculation stop. for example
\code{stop_rate=5} means the calculation stop if there is a week with less then
5\% accessibles states.}

\item{debug_week}{the number of the week to open the process in debug mode}

\item{correct_concavity}{Binary argument (default to false). True to correct concavity of Bellman values.}

\item{correct_monotony_gain}{Binary argument (default to false). True to correct monotony of gains.}

\item{penalty_low}{Penalty for violating the bottom rule curve, comparable to the unsupplied energy cost}

\item{penalty_high}{Penalty for violating the top rule curve, comparable to the spilled energy cost}

\item{method_old_gain}{If T, linear interpolation used between simulations reward, else smarter interpolation based on marginal prices}

\item{controls_reward_calculation}{If method_old_gain=F, vector of controls evaluated}

\item{max_hydro_hourly}{Hourly maximum pumping and turbining powers}

\item{max_hydro_weekly}{Weekly maximum pumping and turbining powers}

\item{force_final_level}{Binary. Whether final level should be constrained}

\item{final_level}{Final level (in percent between 0 and 100) if final level is constrained but different from initial level}

\item{penalty_final_level_low}{Penalties for both bottom rule curve to constrain final level}

\item{penalty_final_level_high}{Penalties for top rule curve to constrain final level}

\item{...}{further arguments passed to or from other methods.}
}
\value{
List of a data.frame with aggregated water values and
a data.frame of more detailed water values
}
\description{
Calculate grid layer matrix of Bellman values and water values
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multistock_1simulation.R
\name{getBellmanValuesFromOneSimulationMultistock}
\alias{getBellmanValuesFromOneSimulationMultistock}
\title{Compute Bellman values for several storage based on one simulation}
\usage{
getBellmanValuesFromOneSimulationMultistock(
  opts,
  path_solver,
  mcyears,
  list_areas,
  list_pumping,
  list_efficiency,
  penalty_final_level_low,
  penalty_final_level_high,
  penalty_low,
  penalty_high,
  write_vu = F,
  simu = NULL
)
}
\arguments{
\item{opts}{List of study parameters returned by the function \code{antaresRead::setSimulationPath(simulation="input")} in input mode.}

\item{path_solver}{Character containing the Antares Solver path, argument passed to \code{\link[antaresEditObject]{runSimulation}}.}

\item{mcyears}{Vector of integer. Monte Carlo years used to compute water values.}

\item{list_areas}{Vector of areas concerned by simulations.}

\item{list_pumping}{Named vector of binary to tell if pumping is available in areas.}

\item{list_efficiency}{Named vector of pumping efficiency.}

\item{penalty_final_level_low}{Double. Penalties for both bottom rule curve to constrain final level.}

\item{penalty_final_level_high}{Double. Penalties for top rule curve to constrain final level.}

\item{penalty_low}{Double. Penalty for violating the bottom rule curve, comparable to the unsupplied energy cost.}

\item{penalty_high}{Double. Penalty for violating the top rule curve, comparable to the spilled energy cost.}

\item{write_vu}{Binary. True to write water values in the Antares study.}

\item{simu}{List of simulation parameters returned by the function \code{antaresRead::setSimulationPath()} with the simulation selected from which to use the storage trajectory to run the simulation.}
}
\value{
A \code{dplyr::tibble()} similar to \code{aggregated_results} from \code{Grid_Matrix()} with one additional column \code{"area"}.
}
\description{
First, an Antares simulation (based on short-term trajectories or trajectories given by the simulation output of \code{simu}) is run.
Marginal prices and costs of this simulation are used to build univariate and independent reward functions for each area with the function \code{get_Reward()} with \code{method_old = F}.
Finally, Bellman values and water values are computed with \code{Grid_Matrix()}.
This method is fast and gives good results when storage are not too important in the study. Otherwise, it is better to compute Bellman values storage per storage.
}
